				Включение ES модулей

По умолчанию ES модули не работают. Их нужно включить. Для этого в файле package.json указать настройку "type" со значением "module":
{
	"type" : "module"
}


*cd "path"


				Установка сборщика Webpack

Установить модули:
npm install webpack --save-dev

Теперь установим также Webpack CLI, позволяющий обращаться к сборщику через командную строку:
npm install webpack-cli --save-dev

npm --versions


			Принцип работы сборщика Webpack

Как правило, при разработке у нас получается много JavaScript файлов, содержащих различные кусочки кода. Это могут быть части нашего кода, либо сторонние библиотеки. Получается, что каждый такой файл мы должны подключить к HTML файлу через тег script.

Это не очень хорошо, так как много подключенных файлов замедляют скорость загрузки сайта. Поэтому для ускорения загрузки необходимо весь код сложить в один файл.

Однако, разрабатывать код в одном общем файле тоже не очень удобно. Поэтому в настоящее время практикуется следующий подход: код разрабатывается в отдельных файлах, а затем с помощью сборщика собирается в один общий файл, который и подключается к HTML файлу.

Отдельные файлы представляют собой ES модули. Эти модули подключаются к другим файлам через команду import.

Обычно создают некий основной файл, к которому подключаются остальные файлы. Этот файл называется точка входа.

Сборщик заходит в точку входа, смотрит какие модули подключены к ней. К этим модулям также могут быть подключены другие модули. Сборщик следует по всем подключениям и собирает весь код в один файл. Этот файл называется бандл.

Как правило, код, который пишет программист, располагается в папке src, а собранный код помещается в папку dist.

Сборщик также позволяет регулировать режим сборки. Режим 'development' предназначен для процесса разработки. Он собирает код удобным для разработки образом. Режим 'production' предназначен для итогового кода, который будет выложен в работу. В этом режиме код будет минифицирован, чтобы уменьшить его размер и увеличить скорость загрузки. 


				Настройка сборщика Webpack

Установленый сборщик должен быть настроен. Это делается в специальном конфигурционном файле webpack.config.js. В этом файле настройка mode регулирует режим сборки, настройка entry задает точку входа, а настройка output - имя бандла.

Создадим файл настроек со следующим содержимым:
export default {
	mode: 'development',
	entry: './src/index.js',
	output: {
		filename: './dist/bundle.js',
	}
};



				Тестовая сборка через Webpack

Давайте сделаем тестовую сборку. Для этого сделаем тестовый файл с точкой входа:
alert('it works');

В терминале, находясь в корневой папке вашего сайта, выполните сборку:
npm run build

В результате в папке dist должен появиться файл bundle.js, содержащий сборку. 



				Подключение бандла к верстке

Для того, чтобы можно было запускать собранный код, его нужно подключить к верстке. Для этого в папке dist сделаем следующий файл:
	<!DOCTYPE html>
	<html>
	<head>
	<title>test</title>
	<script defer src="bundle.js"></script> 
	</head>
	<body>text</body>
	</html>



				Создание ES модуля

Каждый модуль должен представлять собой отдельный файл. Переменные и функции в этом файле, не будут доступны снаружи файла. Так не будет конфликта с именами из других библиотек.

Те переменные и функции, которые мы хотим сделать видимыми снаружи, мы должны экспортировать с помощью команды export.

Пример:
Пусть функции для извлечения корней будут основными и будут экспортироваться наружу, а функция для округления - вспомогательной и не будет экспортироваться. для экспорта нужных функций используется команда export:
export function root2(num) {
	return round(num ** (1 / 2));
}
export function root3(num) {
	return round(num ** (1 / 3));
}
function round(num) {
	return num.toFixed(2);
}



				Подключение ES модуля

Чтобы подключить модуль к другому файлу необходимо использовать команды import и from.

После команды import в фигурных скобках пишутся имена импортируемых функций. А после команды from - путь к импортируемому файлу.

import {root2, root3} 
	from './math.js'; 

После такого подключения будут доступны функции root2 и root3. 
let res = root2(2) + root3(3);
console.log(res);


				Переименование при импорте

Можно переименовывать функции при импорте. Это делается с помощью команды as. 
import {root2 as sqrt, 
	root3} from './math.js'; 

Проверим работу кода:
let res = sqrt(2) + root3(3);
console.log(res);


				Импорт всего содержимого модуля

Можно импортировать все содержимое модуля с помощью следующего синтаксиса:
import * as math from 
	'./math.js'; 

Теперь будет доступен объект math, содержащий все экспортированные функции. Давайте воспользуемся ими:
let res = math.root2(2) 
	+ math.root3(3); 
console.log(res);


				Экспорт по умолчанию

Из модуля ES можно экспортировать только одно значение. Это делается при помощи команды export default. При экспорте с помощью этой команды в переменную при импорте модуля попадет именно импортированное значение.

Экспортируем одну функцию:
export default function() {
	return 'text';
};

Выполним импорт:
import test from './test.js';

Проверим работу функции:
let res = test();
console.log(res);


				Комбинация экспортов

Можно комбинировать экспорт по умолчанию и обычные экспорты:
export function func1() {
	return '1'}

export function func2() {
	return '2'}

export default function() {
	return 'text';};

Выполним импорт:
import test, {func1, func2} from './test.js'; 

Проверим работу функции по умолчанию:
let res = test();
console.log(res);

Проверим работу остальных функций:
let res1 = func1();
let res2 = func2();

console.log(res1, res2);


		Импорт всего содержимого при комбинации экспортов

При комбинации экспортов можно импортировать функцию по умолчанию и все остальные функции в виде объекта.

Экспорты:
export function func1() {
	return '1'}
export function func2() {
	return '2'}
export default function() {
	return 'text';};

Импортируем функцию по умолчанию и все остальные функции с именем mod:
import test, * as mod 
	from './test.js'; 

Проверим работу функции по умолчанию:
let res = test();
console.log(res);

Проверим работу остальных функций:
let res1 = mod.func1();
let res2 = mod.func2();

console.log(res1, res2);


			Экспорт значений из ES модулей

Можно экспортировать не только функции, но и другие значения. Д
	
	Экспорт строк
export default 'test';
Выполним импорт:
import str from './test.js';
console.log(str);

	Экспорт массивов
Экспортируем массив:
export default [1, 2, 3, 4];
Выполним импорт:
import arr from './test.js';
console.log(arr);

	Экспорт объектов
Экспортируем объект:
export default {
	a: 1,
	b: 2,
	c: 3
};
Выполним импорт:
import obj from './test.js';
console.log(obj);


			Значения как константы в ES модулях

Импортированные значения ведут себя как константы. 
Экспортируем строку:
export default 'aaa';

Выполним импорт:
import str from './test.js';

Попробуем изменить строку:
str = 'bbb'; // ошибка


				Импорт npm модулей

Подключать можно не только свои модули, но и модули, установленные через npm. При этом для своих модулей нужно указывать спереди ./, а для npm модулей - не нужно.

Установим библиотеку underscore:
npm install underscore

Подключим ее:
import _ from 'underscore';

Воспользуемся какими-нибудь функциями подключенной библиотеки:
import _ from 'underscore';

let arr = [1, 2, 3, 4, 5]
let res = _.first(arr) + _.last(arr); 
console.log(res);

Можно импортировать не все функции, а только необходимые:
import {first, last} 
	from 'underscore'; 

let arr = [1, 2, 3, 4, 5]
let res = first(arr) 
	+ last(arr); 
console.log(res);



			Динамический импорт ES модулей

ES модули можно импортировать динамически. Эта возможность иногда бывает полезной. Модуль:
export function func1() {
	return '1'}
export function func2() {
	return '2'}
export default function() {
	return 'text';};

Пусть мы хотим импортировать этот модуль не сразу, а по некоторому событию, например, по клику на кнопку:
btn.addEventListener('click', 
	function() { });

Импортируем модуль с помощью команды import:
btn.addEventListener('click', 
	function() { import('./test.js');});

Команда import своим результатом возвращает промис:
btn.addEventListener('click', 
	function() { 
	import('./test.js').then(mod 
		=> { });
});

В переменную коллбэка попадет объект с экспортированными функциями:
btn.addEventListener('click', 
	function() { 
	import('./test.js').then(mod 
		=> { 
		let res1 = mod.func1();
		let res2 = mod.func2();
		
		console.log(res1, res2);
	});
});

То, что экспортируется по умолчанию, будет лежать в ключе default:
btn.addEventListener('click', 
	function() { 
	import('./test.js').then(mod 
		=> { 
		let dfn = mod.default;
		console.log(dfn);
	});
});

Можно выполнять деструктуризацию при импорте:
btn.addEventListener('click', 
	function() { 
	import('./test.js').then(({func1, 
		func2}) => { 
		let res1 = func1();
		let res2 = func2();
		
		console.log(res1, res2);
	});
});




			Динамический множественный импорт

Можно динамически импортировать сразу несколько модулей:
btn.addEventListener('click', 
	function() { 
	Promise.all([
		import('./module1.js'),
		import('./module2.js'),
		import('./module3.js'),
	])
	.then(([module1, module2, 
		module3]) => { 
		
	});
});



				Преобразование CommonJS модулей

До сих пор в различных документациях можно встретить импорты в стиле CommonJS модулей. Вам нужно научиться преобразовывать эти импорты в стандартные ES модули.

В CommonJS импорты выполняются с помощью команды require, параметром которой указывается путь к модулю. Результат команды записывается в переменную:
let math = require('./math');

Давайте перепишем этот код в стиле ES. Для начала обратите внимание на то, что в CommonJS не ставится расширение .js для файлов, а в ES - ставится.

Далее все зависит от того идет ли из модуля экспорт по умолчанию или обычный. В CommonJS нет разницы, а в ES модулях - есть. Как правило, разница видна по примерам кода, либо можно просто попробовать оба варианта импорта.

В нашем случае приведенный импорт перепишется либо в таком виде:
import math from './math.js';

Либо вот в таком виде:
import * as math from 
	'./math.js'; 




