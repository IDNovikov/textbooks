                Установка фреймворка React

Для установки фреймворка вам понадобятся NodeJS не ниже версии 8.10 и npm не 
ниже версии 5.6 на вашем компьютере. 
Для создания проекта в командной строке:
npx create-react-app my-app
cd my-app
npm start

После этого появится папка my-app, содержащая в себе фреймворк.
Папка src - это рабочая папка, в которой будет вестись разработка проекта.

Файл App.js.,этот файл будет основным рабочим файлом.
В нем можно писать код, наблюдая его результаты в окне браузера.

В файле удалить лишнее и привести его вот к такому виду:

    import React from 'react';
    function App() {
	    return <div>
	    	text
	    </div>;
    }
    export default App;

После того, как проект установлен, для следующего запуска
(например, после перезагрузки компьютера) достаточно будет перейти 
через терминал в папку my-app и выполнить следующую команду:
        npm start


                
                Подключение плагина react-devtools

-помогающий вести разработку на React.


                Введение в компонентный подход в React

Пусть у нас есть сайт. На этом сайте мы можем выделить некоторые блоки:
хедер, контент, сайдбар, футер и так далее. Каждый блок можно разделить на
более мелкие подблоки. К примеру в хедере обычно можно выделить логотип, 
менюшку, блок контактов и так далее.

В React каждый такой блок называется компонентом. Каждый компонент может 
содержать в себе более мелкие компоненты, те в свою очередь еще более мелкие 
и так далее.

Каждому компоненту в React соответствует ES6 модуль,
расположенный в папке src. Имя файла с модулем пишется с большой
буквы и должно соответствовать функции, которая расположена в 
коде этого модуля.

Например, файл с названием App.js должен содержать внутри себя функцию App:

    import React from 'react';
    function App() {
	    // код компонента
    }

    export default App;

Один из компонентов должен быть основным - тем, к которому 
добавляются остальные компоненты. В React по
умолчанию таким компонентом будет компонент App. К этому компоненту будут
подключаться другие компоненты. Как это делается - мы разберем далее в учебнике. 



                    Макет сайта фреймворка React

В папке my-app/public в файле index.html расположен макет сайта.
мОЖНО размещать в нем любой HTML код - и увидеть результат этого
кода в браузере.

Кроме того, в макете сайта есть специальный див с id, равным root,
в который монтируется основной компонент. Под монтированием понимается то, 
что в этот див будет выводится результат работы компонента.


                    Результат работы компонента

В див с результатом будет выведено то, что возвращает через return 
функция компонента. В следующем примере это будет див с текстом:

    function App() {
	    return <div>
	    	text
	    </div>;
    }

*див мы пишем без кавычек - просто пишем тег в JavaScript коде! 
Это основная особенность React.



                        Введение в язык JSX в React

Язык JSX - это обычный JavaScript, но с некоторыми дополнениями, 
позволяющими писать теги прямо в коде, без кавычек.

Теги можно возвращать через return:
    function App() {
	    return <div>
		    text
	    </div>;
    }

У тегов могут быть атрибуты:
    function App() {
	    return <div class="eee">
	    	text
	    </div>;
    }

Теги можно записывать в переменные или константы:
    function App() {
	    const  elem = <div>text</div>;
	    return elem;
    }



                Возврат вложенных тегов JSX функциями

Внутри тега, который возвращается через return, может быть сколько угодно 
вложенных тегов:
function App() {
	return <div>
		<p>text1</p>
		<p>text2</p>
	</div>;
}



             Правила возврата функцией при сносе тега вниз в JSX

Открывающий тег обязательно должен быть написан на одной строке с командой 
return. Например, следующий код работать не будет:
    function App() {
	    return
		    <div>
		    	<p>text1</p>
			    <p>text2</p>
		    </div>;
    }

Для того, чтобы такой снос тега вниз заработал, тег необходимо взять
в круглые скобки:
    function App() {
	    return (
		    <div>
			    <p>text1</p>
			    <p>text2</p>
		    </div>
	    );
    }



                    Особенности возврата нескольких тегов в JSX

Через return нельзя возвращать сразу несколько тегов. 
То есть следующий код работать не будет:

    function App() {
	    return (
	    	<div>
		    	<p>text1</p>
		    	<p>text2</p>
	    	</div>
		    <div>
		    	<p>text3</p>
		    	<p>text4</p>
		    </div>
	    );
    }

Чтобы заработало, придется взять теги в какой-нибудь общийтег, например, 
вот так:
    function App() {
	    return (
		    <div>
		    	<div>
			    	<p>text1</p>
			    	<p>text2</p>
		    	</div>
		    	<div>
		    		<p>text3</p>
		    		<p>text4</p>
		    	</div>
		    </div>
	    );
    }

ЛИБО БЕХ ОБЕРТКИ (ПРАВИЛЬНЕЕ)
специальный пустой тег <></>, который группирует теги, 
но в готовую верстку не попадает:

    function App() {
	    return (
		    <>
		    	<div>
		         	<p>text1</p>
			    	<p>text2</p>
		    	</div>
			    <div>
				    <p>text3</p>
				    <p>text4</p>
			    </div>
		    </>
	    );
    }


                     Возврат незакрытого тега JSX

В качестве результата можно возвращать тег, который не нужно закрывать, например,
инпут. Как вы уже знаете, по правилам React в этом случае вместо тега 
<input> нужно писать тег <input />:

    function App() {
	    return <input />;
    }




                     Возврат функцией пустого тега в JSX

Пусть мы хотим вернуть пустой тег:

    function App() {
	    return <div></div>;
    }

В этом случае код можно сократить вот так:

    function App() {
	    return <div />;
    }

При этом в получившемся HTML коде React автоматические преобразует 
сокращенную форму в нормальную. 


                Вставка значений переменных и констант в JSX

Пусть у нас есть следующий код:

    function App() {
	    const str = 'text';
	
	    return <div>
		    text
	    </div>;
    }

Для этого константу нужно написать в фигурных скобках внутри, вот так:

    function App() {
	    const str = 'text';
	
	    return <div>
	    	{str}
	    </div>;
    }




                Нюансы при вставке значений переменных

Кроме вставки константы в теге может быть еще какой-нибудь текст:
function App() {
	const str = 'text';
	
	return <div>
		eee {str} bbb
	</div>;
}

В один тег можно вставлять сколько угодно констант:
function App() {
	const str1 = 'text1';
	const str2 = 'text2';
	
	return <div>
		{str1} {str2}
	</div>;
}

Вставки констант также могут разделяться каким-либо текстом:
function App() {
	const str1 = 'text1';
	const str2 = 'text2';
	
	return <div>
		{str1} eee {str2}
	</div>;
}



                    Вставка массивов в JSX

Можно выполнять вставку массивов. Пример:
    function App() {
	    const arr = [1, 2, 3];
	
	    return <div>
	    	<p>{arr[0]}</p>
	    	<p>{arr[1]}</p>
	    	<p>{arr[2]}</p>
	    </div>;
    }



                        Вставка и объектов в JSX

Можно выполнять вставку объектов. Пример:
    function App() {
	    const obj = {a: 1, b: 2, c: 3};
	
	    return <div>
	    	<p>{obj.a}</p>
	    	<p>{obj.b}</p>
	    	<p>{obj.c}</p>
    	</div>;
    }



             Вставка переменных и констант в атрибуты тегов в JSX

Вставку переменных и констант можно делать не только в тексты тегов, 
но и в атрибуты. При этом кавычки от атрибутов не ставятся:

    function App() {
	    const str = 'elem';
	
	    return <div id={str}>
		    text
	    </div>;
    }

Результатом работы этого кода будет следующее:
    <div id="elem">
    	text
    </div>


                Хранение тегов в переменных и константах JSX

В переменных и константах можно хранить теги, выполняя затем их вставку
в нужное место.

Смотрите пример:

    function App() {
	    const str = <p>text</p>;
	
	    return <div>
		    {str}
	    </div>;
    }



            Особенности хранения нескольких тегов в константах JSX

Необходимо учитывать, что несколько тегов, хранящихся в константе,
обязательно нужно обернуть в какой-то общий тег. 
Так код не будет работать:

    function App() {
	    const str = <p>text1</p><p>text2</p>;
	
	    return <main>
	    	{str}
	    </main>;
    }   

А вот так будет, так как абзацы обернуты в один тег div:
    function App() {
	    const str = <div>
	    	<p>text1</p><p>text2</p>
		    </div>; 
	
	    return <main>
	    	{str}
	    </main>;
    }

    Можно также использовать пустые теги:
    function App() {
    	const str = <><p>
	    	text1</p><p>text2</p>
	    	</>; 
	
    	return <main>
	    	{str}
	    </main>;
    }



                    Теги на разных строках в JSX

Теги, записываемые в константы, не обязательно писать на одной строке.
Можно сделать и так:
    function App() {
	    const str = <p>
	    	text
	    </p>;
	
	    return <div>
	    	{str}
    	</div>;
    }

А можно и вот так:
    function App() {
    	const str = (
	    	<p>
	    		text
	    	</p>
	    );
	
    	return <div>
    		{str}
    	</div>;
    }



                    Возврат тегов через return в JSX

Константы с тегами можно возвращать через return:
    function App() {
	    const str = <main>
	    	text
    	</main>;
	
    	return str;
    }

                                Закрытость тегов JSX

Все теги в JSX должны быть закрыты, в том числе теги, которые не требуют пары, 
например, input или br.

Следующий пример кода выдаст ошибку, так как инпут не закрыт:
function App() {
	return <div>
		<input>
	</div>;
}

Закроем его с помощью обратного слеша:
function App() {
	return <div>
		<input />
	</div>;
}

Функция в вашем основном компоненте сейчас должна выглядеть следующим образом:
function App() {
	return <div>
		text
	</div>;
}


                    Корректность верстки в React

Верстка в JSX должна быть корректной. В частности, не все теги можно 
вкладывать друг в друга. Например, если в теге ul разместить абзац, 
это приведет к ошибке.

Помимо более-менее очевидных недопустимых вложенностей, 
есть также и неожиданные: таблицы.

В таблицах мы привыкли сразу в тег table вкладывать теги tr, вот так:
    function App() {
	    return <table>
	    	<tr>
		    	<td>1</td>
		    	<td>2</td>
	    	</tr>
		    <tr>
		    	<td>3</td>
		    	<td>4</td>
	    	</tr>
	    </table>;
    }

Такой код в React приведет к выводу предупреждения в консоли, 
так как tr должны быть вложены либо в тег tbody, либо в thead, либо в tfoot.

Давайте исправим проблему, сделав нашу таблицу корректной:
function App() {
	return <table>
		<tbody>
			<tr>
				<td>1</td>
				<td>2</td>
			</tr>
			<tr>
				<td>3</td>
				<td>4</td>
			</tr>
		</tbody>
	</table>;
}


                            Выполнение кода JavaScript

Внутри фигурных скобок можно не только вставлять переменные и константы,
но и выполнять произвольный JavaScript код. Давайте, к примеру, в момент 
вставки найдем сумму двух констант:

    function App() {
	    const num1 = 1;
	    const num2 = 2;
	
	    return <div>
	    	{num1 + num2}
    </div>;
    }


							Применение условий в JSX

Cделаем так, чтобы в зависимости от содержимого константы show
на экран вывелся или один, или другой текст:

	function App() {
		let text;
		const show = true;
	
		if (show) {
			text = 'text1';
		} else {
			text = 'text2';
		}
	
	return <div>
		{text}
	</div>;
	}

Можно сделать так, чтобы в переменной хранился не текст, а тег:
	function App() {
		let text;
		const show = true;
	
		if (show) {
			text = <p>text1</p>;
		} else {
			text = <p>text2</p>;
		}
	
		return <div>
			{text}
		</div>;
	}



							Показ по условию в React

Чтобы текст показывался, если в show будет true, и не показывался, 
если в ней будет false:

	function App() {
		let text;
		const show = true;
	
		if (show) {
			text = <p>text</p>;
		}
	
		return <div>
			{text}
		</div>;
	}


						Условия для возврата тега в JSX

Можно возвращать через return переменную, содержащую тег:
	function App() {
		let text;
		const show = true;
	
		if (show) {
			text = <p>text1</p>;
		} else {
			text = <p>text2</p>;
		}
	
			return text;
}



						Тернарный оператор в JSX

Dнутри фигурных скобок можно выполнять JavaScript код. На самом деле этот 
код может быть не любым, а только самым простым.

В частности, условия if там применять нельзя. Взамен следует пользоваться 
сокращенными вариантами условий.

Давайте в зависимости от значения константы show выведем один или
другой текст. Используем для этого тернарный оператор:

	function App() {
		const show = true;
	
		return <div>
			{show ? 'text1' : 'text2'}
		</div>;
	}

Можно работать не только с текстами, но и с тегами:
	function App() {
		const show = true;
	
		return <div>
			{show ? <p>text1</p> : <p>text2</p>}
		</div>;
	}



					Использование оператора && в JSX

Может понадобится выполнить вставку текста, если условие истинно, 
и ничего не делать, если ложно. Это делается с помощью оператора &&.

Если в show будет true, то вставиться абзац с текстом, а если будет
false, то ничегоне вставится:

	function App() {
		const show = true;
	
		return <div>
			{show && <p>text</p>}
		</div>;
	}


			Инвертирование для сокращенных условий в JSX в JSX

Если ужно выполнить вставку текста, если условие ложно, и ничего не 
делать, если истинно. Для этого нужно выполнить инвертирования константы
с помощью оператора !.

В следующем примере, если в hide будет false, то вставится абзац с текстом:
	function App() {
		const hide = false;
	
		return <div>
			{!hide && <p>text</p>}
		</div>;
	}



					Использование функций в React

Внутри основной функции компонента можно делать вспомогательные функции.
К примеру, давайте с помощью вспомогательных функций найдем сумму степеней
двух чисел и выведем ее в тексте тега:
	
	
	function App() {
		function square(num) {
				return num ** 2;
		}
	
		function cube(num) {
			return num ** 3;
		}
	
		const sum = square(3) + cube(4);
	
		return <div>
			{sum}
		</div>
	}


				Вызов функций внутри тегов в React

Функции можно вызывать прямо в фигурных скобках:
	function App() {
		function square(num) {
			return num ** 2;
		}
	
		return <div>
			{square(3)}
		</div>
	}

В фигурных скобках можно также делать вызовы нескольких функций:
	function App() {
		function square(num) {
			return num ** 2;
		}
	
		function cube(num) {
			return num ** 3;
		}
	
		return <div>
			{square(3) + cube(4)}
		</div>
	}



					Навешивание событий в JSX



По событию onclick - по клику на див срабатывает функция showMess.
Для этого нужно добавить атрибут onClick, а в нем 
указать функцию, которая выполнится по этому событию:

function App() {
	function showMess() {
		alert('hello');
	}
	
	return <div>
		<button onClick={showMess}>show</button>
	</div>;
}

Таким образом и происходит работа с событиями: добавляется атрибут 
(к примеру, onClick или onFocus), значением атрибута указывается метод,
 который будет вызван по этому событию. 



						 Параметры в функции JSX

Функция showMess параметром принимает имя того, с кем мы хотим 
поздороваться:

	function showMess(name) {
		alert('hello, ' + name);
	}

Можно передать этот параметр при привязывании функции к событию. Для этого вызов нашей функции следует обернуть в стрелочную функцию:

	function App() {
		function showMess(name) {
			alert('hello, ' + name);
		}
	
		return <div>
			<button onClick={() => showMess('user')}>
				show</button> 
		</div>;
	}

Таким образом мы можем привязать одну и ту же функцию к нескольким кнопкам с разными параметрами:
	function App() {
		function showMess(text) {
			alert(text);
		}
	
		return <div>
			<button onClick={() => showMess('user1')}>
				show1</button> 
			<button onClick={() => showMess('user2')}>
				show2</button> 
		</div>;
	}




						Объект Event в React

Внутри функции, привязанной к обработчику событий, доступен объект Event:

function App() {
	function func(event) {
		console.log(event.target); // объект с событием 
	}
	
	return <div>
		<button onClick={func}>act</button>
	</div>;
}

В переменную event попадает не родной объект Event браузера, а специальная кроссбраузерная обертка над ним со стороны React. Эта обертка называется SyntheticEvent. Эта обертка помогает событиям работать одинаково во всех браузерах. У нее такой же интерфейс, как и у нативного события, включая методы stopPropagation и preventDefault. 



				Объект Event при передаче параметров

Пусть у нас есть некоторая функция func, которую мы хотим использовать в качестве обработчика события. Пусть эта функция принимает некоторый параметр:

function func(arg) {
	console.log(arg);
}

Давайте используем эту функцию в качестве обработчика, передав ей параметр:

function App() {
	function func(arg) {
		console.log(arg);
	}
	
	return <div>
		<button onClick={() => func('eee')}>
			act</button> 
	</div>;
}

Пусть теперь кроме параметра мы хотим получить в нашей функции объект Event. Для этого нам нужно поступить следующим образом:
function App() {
	function func(arg, event) {
		console.log(arg, event);
	}
	
	return <div>
		<button onClick={event => func('eee', 
			event)}>act</button> 
	</div>;
}



							Теги в массивах JSX

Пусть у нас в массиве хранятся теги:

function App() {
	const arr = [<p>1</p>, <p>2</p>, <p>3</p>]; 
}

Мы можем выполнить вставку содержимого нашей переменной с помощью фигурных скобок:

function App() {
	const arr = [<p>1</p>, <p>2</p>, <p>3</p>]; 
	
	return <div>
		{arr}
	</div>;
}

В результате теги из массива вставятся в указанное место и после рендеринга получится следующий код:
<div>
	<p>1</p>
	<p>2</p>
	<p>3</p>
</div>


				Формирование массива тегов в цикле React

Массив с тегами можно создать в цикле:
function App() {
	const arr = [];
	
	for (let i = 0; i <= 9; i++) {
		arr.push(<p>{i}</p>);
	}
	
	return <div>
		{arr}
	</div>;
}

				Формирование тегов из массива с данными

function App() {
	const arr = [1, 2, 3, 4, 5];
	
	const res = arr.map(function(item) {
		return <p>{item}</p>;
	});
	
	return <div>
		{res}
	</div>;
}

однако, если заглянуть в консоль - мы увидим ошибку: Warning: Each child in an array or iterator should have a unique "key" prop. В данном случае React требует, чтобы каждому тегу из цикла мы дали уникальный номер. Этот номер добавляется с помощью атрибута key. В данном случае в качестве номера мы можем взять номер элемента в массиве. В нашем случае этот номер хранится в переменной index и значит исправленная строка будет выглядеть вот так:

function App() {
	const arr = [1, 2, 3, 4, 5];
	
	const res = arr.map(function(item, index) {
		return <p key={index}>{item}</p>;
	});
	
	return <div>
		{res}
	</div>;
}
*но лучше приписывать отдлеьный id


					Вывод массива объектов в React

Пусть у нас есть массив объектов с продуктами:

const prods = [
	{id: 1, name: 'product1', cost: 100},
	{id: 2, name: 'product2', cost: 200},
	{id: 3, name: 'product3', cost: 300},
];

function App() {
	const res = prods.map(function(item) {
		return <p key={item.id}>
			<span>{item.name}</span>:
			<span>{item.cost}</span>
		</p>;
	});
	
	return <div>
		{res}
	</div>;
}


			Вывод массива объектов в виде HTML таблицы


	function App() {
	const rows = prods.map(function(item) {
		return <tr key={item.id}>
			<td>{item.name}</td>
			<td>{item.cost}</td>
		</tr>;
	});
	
	return <table>
		<thead>
			<tr>
				<td>название</td>
				<td>стоимость</td>
			</tr>
		</thead>
		<tbody>
			{rows}
		</tbody>
	</table>;
}


***
В массиве объектов должны присутствовать уникальные id. 

Массивы объектов могут иметь два происхождения: либо они присланы нам сервером, либо сгенерированы на клиенте (то есть в браузере).

Данные, присланные нам сервером, как правило хранились там в базе данных. Базы данных (БД) бывают вида SQL (например, mySQL, PostgreSQL) или NoSQL (например, MongoDB).
SQL базы данных, как правило имеют числовые id, автоматически расставляемые базой данных по возрастанию.

NoSQL базы данных, как правило, имеют id, представляющие собой случайные уникальные строки. Предполагается, что эти строки не имеют совпадений (коллизий) у двух элементов массива.

Уникальность id достигается за счет достаточно большой длины случайных строк - настолько больших, что вероятность совпадения двух строк будет близка в нулю.

При этом, чем больше данных в БД, тем больше вероятность коллизии. Задача программиста состоит в том, чтобы заранее прикинуть объем данных и определить оптимальную длину случайных строк, чтобы вероятность коллизий была минимальна (достаточно мала, чтобы считаться приемлемой).

!библиотека nanoid, генерирующая случайные строки, либо библиотека react-uuid, генерирующая UUID. 

import React from 'react';
import { nanoid } from 'nanoid'

function id () {
	return nanoid()
}

const prods = [
	{id: id(), name: 'product1', cost: 100},
	{id: id(), name: 'product2', cost: 200},
	{id: id(), name: 'product3', cost: 300},
];

function App() {
	const res = prods.map(function(item) {
		return <p key={item.id}>
			<span> {item.id} </span>
			<span>{item.name}</span>:
			<span>{item.cost}</span>
		</p>;
	});
	
	return <div>
		{res}
	</div>;
}

export default App;
***


				Использование функции id в React
!НЕЛЬЗЯ ГЕНЕРИРОВАТЬ ID в атрибуте:

const res = prods.map(function(prod) {
	return <p key={id()}>
		<span>{prod.name}</span>
		<span>{prod.cost}</span>
	</p>;
});
Использовать нашу функцию следующим образом при объявлении массива объектов:

const prods = [
	{id: id(), name: 'product1', cost: 100},
	{id: id(), name: 'product2', cost: 200},
	{id: id(), name: 'product3', cost: 300},
];



					Введение в стейты в React

 Стейты представляют собой реактивные переменные компонентов.
Реактивность означает, что при изменении стейта изменения произойдут во всех местах, где этот стейт используется. Технически это достигается путем перендерования всего компонента при изменении какого-либо стейта.

Для использования стейтов для начала необходимо импортировать функцию useState:

import React, { useState } from 'react';

Функция useState параметром принимает начальное значение стейта, а своим результатом возвращает специальный массив из двух элементов. В первом элементе массива будет хранится текущее значение стейта, а во втором - функция для изменения стейта.

Для корректной работы стейтов их нельзя менять напрямую, а следует пользоваться функцией для их изменения - только тогда будет работать реактивность. 



					Использование стейтов в React

Воспользуемся функцией useState для создания стейта, содержащего название продукта:

const state = useState('prod');

В результате константа state будет представлять собой массив, в первом элементе которого будет хранится название продукта, а во втором - функция для изменения названияя через деструктуризацию:

const [name, setName] = useState('prod');

Давайте теперь выведем наш стейт с именем продукта в какой-нибудь верстке:

return <p>
	<span>{name}</span>
</p>;

Соберем все вместе и получим следующий код:
import React, { useState } from 'react';

function App() {
	const [name, setName] = useState('prod');
	
	return <div>
		<span>{name}</span>
	</div>;
}

export default App;

Если запустить этот код, то изначально в диве выведется начальное значение стейта, в нашем случае 'prod'. При изменение стейта через функцию setName и верстке автоматически появится новое значение стейта. 



					Реактивность стейтов в React

Реактивность делает так, что при изменении стейта изменения мгновенно отображаются на экране.

усть у нас есть стейт с названием продукта:

const [name, setName] = useState('prod');

Выведем название продукта в верстке:

return <div>
	<span>{name}</span>
</div>;

Сделаем теперь кнопку, по нажатию на которую наш стейт будет изменяться:

return <div>
	<span>{name}</span>
	<button onClick={clickHandler}>btn</button>
</div>;

В обработчике клика используем функцию setName, чтобы установить продукту новое название:
function clickHandler() {
	setName('xxxx');
}

Соберем весь наш код вместе. Получится, что после нажатия на кнопку текст в спене мгновенно поменяется на новое значение:

function App() {
	const [name, setName] = useState('prod');
	
	function clickHandler() {
		setName('xxxx');
	}
	
	return <div>
		<span>{name}</span>
		<button onClick={clickHandler}>btn</button>
	</div>;
}

Использование отдельных функций-обработчиков не обязательно. Можно использовать анонимную стрелочную функцию:
function App() {
	const [name, setName] = useState('prod');
	
	return <div>
		<span>{name}</span>
		<button onClick={() => setName('xxxx')}>btn</button>
	</div>;
}

				Логическое значение в стейте в React

Стейт inCart, который будет показывать, в корзине продукт или нет:

function App() {
	const [inCart, setInCart] = useState(false);
	
	return <div>
		
	</div>;
}

Пусть значение false значит, что продукт не в корзине, а значение true - что в корзине. Выведем информацию об этом с помощью тернарного оператора:

function App() {
	const [inCart, setInCart] = useState(false);
	
	return <div>
		<span>{inCart ? 'в корзине' : 'не в корзине'}</span>
	</div>;
}

А теперь сделаем кнопку, по нажатию на которую продукт добавится в корзину:
function App() {
	const [inCart, setInCart] = useState(false);
	
	return <div>
		<span>{inCart ? 'в корзине' : 'не в корзине'}</span>
		<button onClick={() => setInCart(true)}>btn</button>
	</div>;
}

Модифицируем наш код так, чтобы первое нажатие на кнопку добавляло в корзину, а второе - удаляло из нее:
function App() {
	const [inCart, setInCart] = useState(false);
	
	return <div>
		<span>{inCart ? 'в корзине' : 'не в корзине'}</span>
		<button onClick={() => setInCart(!inCart)}>btn</button>
	</div>;
}

Счетчик на стейтах: 
function App() {
	const [count, setCount] = useState(0);
	
	return <div>
		<span>{count}</span>
		<button onClick={() => setCount(count + 1)}>+</button>
	</div>;
}



						Работа с инпутами в React

Работа с инпутами в React происходит с помощью стейтов. Каждому инпуту назначается свой стейт, содержащий в себе value инпута.

function App() {
	const [value, setValue] = useState('text');
	
	return <div>
		<input />
	</div>;
}

Давайте к атрибуту value инпута привяжем нас стейт:

function App() {
	const [value, setValue] = useState('text');
	
	return <div>
		<input value={value} />
	</div>;
}

В таком случае получится, что при изменении стейта, реактивно поменяется и текст инпута, но инпуте невозможно поменять текст! Почему: потому что при вводе текста в инпут не меняется стейт value, соответственно, и текст в инпуте не должен меняться, тем самым заблокировали инпут.

Чтобы исправить нужно навесить на инпут событие onChange:

function App() {
	const [value, setValue] = useState('text');
	
	return <div>
		<input value={value} onChange={handleChange} />
	</div>;
}

Данное событие в React ведет себя по-другому по сравнению с чистым JS. В React оно срабатывает сразу же по изменению инпута. То есть при вводе или удалении символа.

Давайте теперь добавим обработчик нашего события:
function App() {
	const [value, setValue] = useState('text');
	
	function handleChange() {
		
	}
	
	return <div>
		<input value={value} onChange={handleChange} />
	</div>;
}

В этом обработчике мы должны прочитать текущий текст инпута и установить его в стейт с помощью функции setValue.

Проблема в том, что this данной функции не будет указывать на наш инпут - такова особенность React. Чтобы получить элемент, в котором случилось событие, нам необходимо использовать event.target:
function App() {
	const [value, setValue] = useState('text');
	
	function handleChange(event) {
		console.log(event.target); // ссылка 
			на DOM элемент инпута 
	}
	
	return <div>
		<input value={value} onChange={handleChange} />
	</div>;
}

Выведем с помощью event.target текущий текст инпута:
function App() {
	const [value, setValue] = useState('text');
	
	function handleChange(event) {
		console.log(event.target.value); // текущий текст инпута
	}
	
	return <div>
		<input value={value} onChange={handleChange} />
	</div>;
}

А теперь запишем текст инпута в наш стейт:
function App() {
	const [value, setValue] = useState('text');
	
	function handleChange(event) {
		setValue(event.target.value);
	}
	
	return <div>
		<input value={value} onChange={handleChange} />
	</div>;
}

Теперь мы сможем вводить текст в инпут. При этом стейт value всегда будет содержать текущий текст инпута.

Мы можем легко убедится в этом. Выведем содержимое нашего текста в абзац. В этом случае при вводе текста в инпут введенный текст будет автоматически появляться в абзаце:
function App() {
	const [value, setValue] = useState('');
	
	function handleChange(event) {
		setValue(event.target.value);
	}
	
	return <div>
		<input value={value} onChange={handleChange} />
		<p>text: {value}</p>
	</div>;
}

Можем переписать на более компактный вариант с анонимной стрелочной функцией:
function App() {
	const [value, setValue] = useState('');
	
	return <div>
		<input value={value} onChange={event 
			=> setValue(event.target.value)} /> 
		<p>text: {value}</p>
	</div>;
}

Таким образом, для работы любого инпута нам нужно следующее: создать стейт для этого инпута, привязать стейт к атрибуту value инпута, навесить событие onChange на инпут, в обработчике события менять стейт инпута на его текст.



			Изменение данных инпута при их выводе в React

Пусть мы будем вводить в инпут число. Давайте сделаем так, чтобы по мере ввода числа в инпут в абзац выводился квадрат вводимого числа:
function App() {
	const [value, setValue] = useState(0);
	
	function handleChange(event) {
		setValue(event.target.value);
	}
	
	return <div>
		<input value={value} onChange={handleChange} />
		<p>{value ** 2}</p>
	</div>;
}


				Изменение данных с помощью функции в React

Не обязательно совершать некие операции над стейтом прямо на выводе. Можно воспользоваться функцией:
function square(num) {
	return num ** 2;
}

function App() {
	const [value, setValue] = useState(0);
	
	function handleChange(event) {
		setValue(event.target.value);
	}
	
	return <div>
		<input value={value} onChange={handleChange} />
		<p>{square(value)}</p>
	</div>;
}



				Работа с несколькими инпутами в React

Пусть у нас есть два инпута, в которые будут вводится числа. Давайте сделаем так, чтобы по мере ввода в абзац выводилась сумма двух инпутов:

function App() {
	const [value1, setValue1] = useState(0);
	const [value2, setValue2] = useState(0);
	
	function handleChange1(event) {
		setValue1(+event.target.value);
	}
	
	function handleChange2(event) {
		setValue2(+event.target.value);
	}
	
	return <div>
		<input value={value1} onChange={handleChange1} />
		<input value={value2} onChange={handleChange2} />
		<p>result: {value1 + value2}</p>
	</div>
}


			Обработка данных формы по нажатию на кнопку в React


Посмотрим на примере. Пусть у нас есть два инпута и кнопка. По нажатию на кнопку давайте найдем сумму чисел, введенных в инпуты.

Реализуем:
function App() {
	const [value1, setValue1] = useState(0);
	const [value2, setValue2] = useState(0);
	const [result, setResult] = useState(0);
	
	function handleChange1(event) {
		setValue1(event.target.value);
	}
	
	function handleChange2(event) {
		setValue2(event.target.value);
	}
	
	function handleClick() {
		setResult(Number(value1) + Number(value2));
	}
	
	return <div>
		<input value={value1} onChange={handleChange1} />
		<input value={value2} onChange={handleChange2} />
		
		<button onClick={handleClick}>btn</button>
		<p>result: {result}</p>
	</div>;
}

Можно использовать сокращенный вариант:
function App() {
	const [value1, setValue1] = useState(0);
	const [value2, setValue2] = useState(0);
	const [result, setResult] = useState(0);
	
	return <div>
		<input value={value1} onChange={event 
			=> setValue1(event.target.value)} /> 
		<input value={value2} onChange={event 
			=> setValue2(event.target.value)} /> 
		
		<button onClick={() => setResult(Number(value1) 
			+ Number(value2))}>btn</button> 
		<p>result: {result}</p>
	</div>;
}



						Работа с textarea в React

Давайте теперь научимся работать с многострочным полем ввода textarea. В React работа с ним, для удобства, сделана похожей на работу с текстовым инпутом. В отличие от чистого JS, в React в textarea не нужен закрывающий тег, а его текст следует размещать в атрибуте value.

function App() {
	const [value, setValue] = useState('');
	
	function handleChange(event) {
		setValue(event.target.value);
	}
	
	return <div>
		<textarea value={value} onChange={handleChange} />
		<p>{value}</p>
	</div>;
}

В сокращенной форме:
function App() {
	const [value, setValue] = useState('');
	
	return <div>
		<textarea value={value} onChange={event 
			=> setValue(event.target.value)} /> 
		<p>{value}</p>
	</div>;
}



					Работа с чекбоксами в React

Bместо атрибута value указываем атрибут checked. Если в этот атрибут передать true - то чекбокс будет отмечен, а если false - не будет отмечен:

function App() {
	return <div>
		<input type="checkbox" checked={true}  /> отмечен
		<input type="checkbox" checked={false} /> не отмечен
	</div>;
}

Обычно в атрибут checked передается стейт, содержащий логическое значение:

function App() {
	const [checked, setChecked] = useState(true);
	
	return <div>
		<input type="checkbox" checked={checked} />
	</div>;
}

 Если жестко задать значение атрибута checked - состояние чекбокса нельзя будет сменить. Для корректной работы будем по изменению чекбокса менять его стейт на противоположное ему значение:

function App() {
	const [checked, setChecked] = useState(true);
	
	function handleChange() {
		setChecked(!checked); // инвертируем стейт
	}
	
	return <div>
		<input type="checkbox" checked={checked} 
			onChange={handleChange} /> 
	</div>;
}

Можем упростить:
function App() {
	const [checked, setChecked] = useState(true);
	
	return <div>
		<input type="checkbox" checked={checked} 
			onChange={() => setChecked(!checked)} /> 
	</div>;
}

Давайте выведем состояние чекбокса в абзац, используя тернарный оператор:
function App() {
	const [checked, setChecked] = useState(true);
	
	return <div>
		<input type="checkbox" checked={checked} 
			onChange={() => setChecked(!checked)} /> 
		<p>состояние: {checked ? 'отмечен' : 'не отмечен'}</p>
	</div>;
}


				Чекбоксы и условный рендеринг в React

Давайте сделаем так, чтобы в зависимости от отметки чекбокса, на экран выводился либо один кусочек кода, либо другой. Используем для этого условный рендеринг:

function App() {
	const [checked, setChecked] = useState(true);
	
	let message;
	if (checked) {
		message = <p>сообщение 1</p>;
	} else {
		message = <p>сообщение 2</p>;
	}
	
	return <div>
		<input type="checkbox" checked={checked} 
			onChange={() => setChecked(!checked)} /> 
		<div>{message}</div>
	</div>;
}


					Работа с селектами в React

Пусть у нас есть вот такой селект:
function App() {
	return <div>
		<select>
			<option>text1</option>
			<option>text2</option>
			<option>text3</option>
			<option>text4</option>
		</select>
	</div>;
}

Давайте обеспечим его работу средствами React:
function App() {
	const [value, setValue] = useState('');
	
	function handleChange(event) {
		setValue(event.target.value);
	}
	
	return <div>
		<select value={value} onChange={handleChange}>
			<option>text1</option>
			<option>text2</option>
			<option>text3</option>
			<option>text4</option>
		</select>
		<p>
			ваш выбор: {value}
		</p>
	</div>;
}



				Пункты селекта из массива в React

Пусть у нас есть массив с текстами пунктов выпадающего списка:

function App() {
	const texts = ['text1', 'text2', 'text3', 'text4'];
	const [value, setValue] = useState('');
	
	const options = texts.map((text, index) => {
		return <option key={index}>{text}</option>;
	});
	
	return <div>
		<select value={value} onChange={(event) => setValue(event.target.value)}>
			{options}
		</select>
		<p>
			ваш выбор: {value}
		</p>
	</div>;
}


					Атрибуты value в селекте в React

Пусть теперь у нас в тегах option есть атрибуты value:
function App() {
	return <div>
		<select>
			<option value="1">text1</option>
			<option value="2">text2</option>
			<option value="3">text3</option>
		</select>
	</div>;
}

В таком случае из-за наличия атрибутов value в стейт будут попадать именно их значения, а не тексты тегов option. Можно убедится в этом, выведя результат выбора в абзац:
function App() {
	const [value, setValue] = useState('');
	
	return <div>
		<select value={value} onChange={(event) => setValue(event.target.value)}>
			<option value="1">text1</option>
			<option value="2">text2</option>
			<option value="3">text3</option>
		</select>
		<p>
			ваш выбор: {value}
		</p>
	</div>;
}

Разделить текст option и его значение может быть удобно: текст тега мы можем менять как нам угодно, при этом в нашем скрипте результат выбора будет обрабатываться по значению атрибута value, которые останется неизменным.

Смотрите пример:

function App() {
	const [value, setValue] = useState('');
	
	return <div>
		<select value={value} onChange={event => setValue(event.target.value)}>
			<option value="1">text1</option>
			<option value="2">text2</option>
			<option value="3">text3</option>
		</select>
		<p>
			{value === '1' && 'вы выбрали первый пункт'}
			{value === '2' && 'вы выбрали второй пункт'}
			{value === '3' && 'вы выбрали третий пункт'}
		</p>
	</div>;
}

Теперь, если мы изменим тексты оптионов, то работа скрипта не нарушится - ведь она привязана к значению атрибута value.



					Атрибуты value селекта из массива в React



function App() {
	const texts = ['text1', 'text2', 'text3', 'text4'];
	const [value, setValue] = useState('');
	
	const options = texts.map((text, index) => {
		return <option key={index} value={index}>{text}</option>;
	});
	
	return <div>
		<select value={value} onChange={event => setValue(event.target.value)}>
			{options}
		</select>
		<p>
			ваш выбор: {texts[value]}
		</p>
	</div>;
}


					Работа с radio в React

У нескольких радио будет один и тот же стейт, но разные value.

Поэтому работа происходит следующем образом: каждой радиокнопке в атрибут value записывают свое значение, а в атрибут checked - специальное условие, которое проверяет, равен ли стейт определенному значению. Если равен - радиокнопочка станет отмеченной, а если не равен - будет не отмеченной.

Вот реализация описанного:
function App() {
	const [value, setValue] = useState(1);
	
	function changeHandler(event) {
		setValue(event.target.value);
	}
	
	return <div>
		<input
			type="radio"
			name="radio"
			value="1"
			checked={value === '1' ? true : false}
			onChange={changeHandler}
		/>
		<input
			type="radio"
			name="radio"
			value="2"
			checked={value === '2' ? true : false}
			onChange={changeHandler}
		/>
		<input
			type="radio"
			name="radio"
			value="3"
			checked={value === '3' ? true : false}
			onChange={changeHandler}
		/>
	</div>
}

					Значения по умолчанию в React

Чтобы по умолчанию в инпуте уже было какое-то значение. При этом нужно, чтобы из стейта было взято только начальное значение инпута, а сам инпут не был бы привязан к этому стейту.

Для решения такой задачи нужно воспользоваться атрибутом defaultValue:

function App() {
	const [value, setValue] = useState('text');
	
	return <div>
		<input defaultValue={value} />
	</div>;
}

Для чекбоксов существует аналогичный атрибут defaultChecked, с помощью которого можно задать начальное:
function App() {
	const [checked, setChecked] = useState(true);
	
	return <div>
		<input type="checkbox" defaultChecked={checked} />
	</div>;
}



					Привязка инпутов к массиву в React

Пусть в стейте notes хранится массив:

	const [notes, setNotes] = useState([1, 2, 3]);


Пусть у нас также есть вспомогательная функция, находящая сумму элементов массива:

function getSum(arr) {
	let sum = 0;
	for (const elem of arr) {
		sum += +elem;
	}
	return sum;
}

Давайте найдем и выведем сумму элементов нашего массива из стейта, использовав для этого нашу вспомогательную функцию:
function App() {
	const [notes, setNotes] = useState([1, 2, 3]);
	
	return <div>
		{getSum(notes)}
	</div>;
}

Давайте теперь сделаем три инпута и в value каждого инпута запишем один из элементов массива:
function App() {
	const [notes, setNotes] = useState([1, 2, 3]);
	
	return <div>
		<input value={notes[0]} />
		<input value={notes[1]} />
		<input value={notes[2]} />
		
		{getSum(notes)}
	</div>;
}

Давайте теперь добавим событие onChange нашим инпутам. При этом сделаем одну общую функцию-обработчик этого события:
function App() {
	const [notes, setNotes] = useState([1, 2, 3]);
	
	function changeHandler(index, event) {
		// общая функция-обработчик
	}
	
	return <div>
		<input value={notes[0]} onChange={event 
			=> changeHandler(0, event)} /> 
		<input value={notes[1]} onChange={event 
			=> changeHandler(1, event)} /> 
		<input value={notes[2]} onChange={event 
			=> changeHandler(2, event)} /> 
		
		{getSum(notes)}
	</div>;
}

Как вы видите, функция changeHandler первым параметром принимает номер того элемента массива, который редактирует данный инпут.

По этому номеру мы можем заменить элемент массива на содержимое инпута.

Сделаем это:
function changeHandler(index, event) {
	setNotes([...notes.slice(0, index), 
		event.target.value, ...notes.slice(index + 1)]); 
}

Теперь можно будет поредактировать любой инпут, при этом реактивно будет изменяться массив и, соответственно, пересчитываться сумма его элементов.

Давайте соберем весь наш код вместе:
function App() {
	const [notes, setNotes] = useState([1, 2, 3]);
	
	function changeHandler(index, event) {
		setNotes([...notes.slice(0, index), 
			event.target.value, ...notes.slice(index + 1)]); 
	}
	
	return <div>
		<input value={notes[0]} onChange={event 
			=> changeHandler(0, event)} /> 
		<input value={notes[1]} onChange={event 
			=> changeHandler(1, event)} /> 
		<input value={notes[2]} onChange={event 
			=> changeHandler(2, event)} /> 
		
		{getSum(notes)}
	</div>;
}

Можно сделать так, чтобы инпуты формировались в цикле:
function App() {
	const [notes, setNotes] = useState([1, 2, 3]);
	
	function changeHandler(index, event) {
		setNotes([...notes.slice(0, index), 
			event.target.value, ...notes.slice(index + 1)]); 
	}
	
	const result = notes.map((note, index) => {
		return <input
			key={index}
			value={note}
			onChange={event => changeHandler(index, event)}
		/>;
	});
	
	return <div>
		{result}
		{getSum(notes)}
	</div>;
}


						Привязка инпутов к объекту в React

Пусть в стейте хранится объект:
const initObj = {
	prop1: 'value1',
	prop2: 'value2',
	prop3: 'value3',
}

function App() {
	const [obj, setObj] = useState(initObj);
	
	return <div>
		{obj.prop1}-{obj.prop2}-{obj.prop3}
	</div>;
}

Давайте выведем каждое свойство нашего объекта в отдельном инпуте:
function App() {
	const [obj, setObj] = useState(initObj);
	
	return <div>
		<input value={obj.prop1} />
		<input value={obj.prop2} />
		<input value={obj.prop3} />
		
		<br />
		{obj.prop1}-{obj.prop2}-{obj.prop3}
	</div>;
}

Давайте теперь к каждому инпуту привяжем событие onChange. В качестве обработчика назначим одну общую функцию:
function App() {
	const [obj, setObj] = useState(initObj);
	
	return <div>
		<input value={obj.prop1} onChange={event 
			=> handleChange('prop1', event)} /> 
		<input value={obj.prop2} onChange={event 
			=> handleChange('prop2', event)} /> 
		<input value={obj.prop3} onChange={event 
			=> handleChange('prop3', event)} /> 
		
		<br />
		{obj.prop1}-{obj.prop2}-{obj.prop3}
	</div>;
}

Как вы видите, функция handleChange первым параметром принимает имя соответствующего свойства объекта.

Давайте напишем реализацию нашей функции:
function handleChange(prop, event) {
	const copy = Object.assign({}, obj);
	copy[prop] = event.target.value;
	setObj(copy);
}

Данная реализация рабочая, но ее можно упростить, если воспользоваться вычисляемыми именами свойств объекта:
function handleChange(prop, event) {
	setObj({...obj, ...{[prop]: event.target.value}});
}

Давайте соберем весь код вместе:
function App() {
	const [obj, setObj] = useState(initObj);
	
	function handleChange(prop, event) {
		setObj({...obj, ...{[prop]: event.target.value}});
	}
	
	return <div>
		<input value={obj.prop1} onChange={event 
			=> handleChange('prop1', event)} /> 
		<input value={obj.prop2} onChange={event 
			=> handleChange('prop2', event)} /> 
		<input value={obj.prop3} onChange={event 
			=> handleChange('prop3', event)} /> 
		
		<br />
		{obj.prop1}-{obj.prop2}-{obj.prop3}
	</div>;
}


				Реактивность данных в React

Cтруктуры данных в React обладают реактивностью. React реактивно реагирует на все изменения данных: на добавление, удаление, изменение элементов, а также на изменение их порядка.

При этом правилами React запрещено изменять данные массивов и объектов из стейта. Нужно делать копию данных, изменять их и записывать обратно в стейт. Это значит, что наши данные должны быть иммутабельными. Читайте про иммутабельность массивов, объектов и массивов объектов в соответствующем разделе учебника JavaScript. 


					Реактивное добавление в массив в React

Давайте поработаем с реактивным добавлением элементов в массив. Пусть для примера у нас есть массив, который выводится в виде списка ul:
function App() {
	const [notes, setNotes] = useState([1, 2, 3, 4, 5]);
	
	const result = notes.map((note, index) => {
		return <li key={index}>{note}</li>;
	});
	
	return <div>
		<ul>
			{result}
		</ul>
	</div>;
}


					Реактивные операции над массивами в React

Давайте теперь научимся делать реактивные манипуляции с элементами массива. Для этого мы на каждую li навесим обработчик события, в которой параметром будем будем передавать номер этой li в массиве:

	function App() {
		const [notes, setNotes] = useState([1, 2, 3, 4, 5]);
	
		const result = notes.map((note, index) => {
			return <li key={index} onClick="() => doSmth(index)">
				{note}
			</li>;
		});
	
		return <div>
			<ul>
				{result}
			</ul>
		</div>;
	}

Внутри нашей функции мы можем совершить любую операцию над нашим элементом массива:
function App() {
	...
	
	function doSmth(index) {
		let copy = Object.assign([], notes);
		copy[index] += '!'; // что-то 
			сделаем с элементом 
		setNotes(copy);
	}
}



					Реактивное добавление в массив объектов в React

Давайте теперь изучим реактивность массива объектов. В данном случае мы должны будем производить любые изменения, обращаясь к элементам по id, которые хранятся внутри самих объектов.

Давайте попробуем. Пусть у нас есть следующий массив объектов:
const initNotes = [
	{
		id: 'GYi9G_uC4gBF1e2SixDvu',
		prop1: 'value11',
		prop2: 'value12',
		prop3: 'value13',
	},
	{
		id: 'IWSpfBPSV3SXgRF87uO74',
		prop1: 'value21',
		prop2: 'value22',
		prop3: 'value23',
	},
	{
		id: 'JAmjRlfQT8rLTm5tG2m1L',
		prop1: 'value31',
		prop2: 'value32',
		prop3: 'value33',
	},
];

Давайте выведем каждый элемент нашего массива в отдельном теге li:
function App() {
	const [notes, setNotes] = useState(initNotes);
	
	const result = notes.map(note => {
		return <li key={note.id}>
			<span>{note.prop1}</span>
			<span>{note.prop2}</span>
			<span>{note.prop3}</span>
		</li>;
	});
	
	return <div>
		<ul>
			{result}
		</ul>
	</div>;
}




	function App() {
let objForAdd = {id:id(), prop1:"",prop2:"",prop3:""}

		const initNotes = [
	{
		id: 'GYi9G_uC4gBF1e2SixDvu',
		prop1: 'value11',
		prop2: 'value12',
		prop3: 'value13',
	},
	{
		id: 'IWSpfBPSV3SXgRF87uO74',
		prop1: 'value21',
		prop2: 'value22',
		prop3: 'value23',
	},
	{
		id: 'JAmjRlfQT8rLTm5tG2m1L',
		prop1: 'value31',
		prop2: 'value32',
		prop3: 'value33',
	},
];

	const [notes, setNotes] = useState(initNotes);
	
	const result = notes.map(note => {
		return <li key={note.id}>
			<span>{note.prop1}</span>
			<span>{note.prop2}</span>
			<span>{note.prop3}</span>
		</li>;
	});
	
	function doSmth (event) {
let copy = Object.assign([], notes);
		copy.push(objForAdd); 
		setNotes(copy);
	}
	return <div>
		<ul>
			{result}
		</ul>
		<input  onBlur={(event)=>{objForAdd.prop1=event.target.value; }}/>
		<input  onBlur={(event)=>{objForAdd.prop2=event.target.value; }}/>
		<input  onBlur={(event)=>{objForAdd.prop3=event.target.value; }}/>
		<button onClick={(event)=>doSmth(event)}>Add to List</button>
	</div>;
}
export default App



					Реактивные операции над массивами объектов в React

Давайте теперь научимся делать реактивные операции над массивами объектов. В этом случае мы должны передать в функцию id элемента массива, с которым мы собираемся что-то делать:
function App() {
	const [notes, setNotes] = useState(initNotes);
	
	const result = notes.map(note => {
		return <li key={note.id}>
			<span>{note.prop1}</span>
			<span>{note.prop2}</span>
			<span>{note.prop3}</span>
			
			<button onClick="() => doSmth(note.id)">
				btn
			</button>
		</li>;
	});
	
	return <div>
		<ul> 
			{result}
		</ul>
	</div>;
}

Для того, чтобы что-то сделать с элементом, мы сначала должны найти его, перебрав весь массив циклом:
function App() {
	...
	
	function doSmth(id) { 
		setNotes(notes.map(note => {
			if (note.id === id) {
				// что-то делаем с элементом
			}
			
			return note;
		}));
	}
}

Давайте для примера поменяем тексты найденного объекта:
function App() {
	...
	
	function doSmth(id) {
		setNotes(notes.map(note => {
			if (note.id === id) {
				note.prop1 += '!';
				note.prop2 += '!';
				note.prop2 += '!';
				
				return note;
			}
			
			return note;
		}));
	}
}


						Реактивный показ данных в React

Пусть у нас есть массив объектов, содержащий в себе названия и описания чего-либо:
const initNotes = [
	{
		id: id(),
		name: 'name1',
		desc: 'long description 1'
	},
	{
		id: id(),
		name: 'name2',
		desc: 'long description 2'
	},
	{
		id: id(),
		name: 'name3',
		desc: 'long description 3'
	},
];

Давайте выведем каждый элемент этого массива в отдельном абзаце:

function App() {
	const [notes, setNotes] = useState(initNotes);
	
	const result = notes.map(note => {
		return <p key={note.id}>
			{note.name}, 
			<i>{note.desc}</i>
		</p>;
	});
	
	return <div>
		{result}
	</div>;
}

Давайте теперь сделаем так, чтобы описание изначально было скрыто, но в конце каждого абзаца добавим кнопки для показа описания из этого абзаца. Для этого в каждый объект с продуктом добавим свойство show, регулирующее показ описания:
const initNotes = [
	{
		id: id(),
		name: 'name1',
		desc: 'long description 1',
		show: false,
	},
	{
		id: id(),
		name: 'name2',
		desc: 'long description 2',
		show: false,
	},
	{
		id: id(),
		name: 'name3',
		desc: 'long description 3',
		show: false,
	},
];



		const initNotes = [
	{
		id: id(),
		name: 'name1',
		desc: 'long description 1',
		show: false,
	},
	{
		id: id(),
		name: 'name2',
		desc: 'long description 2',
		show: false,
	},
	{
		id: id(),
		name: 'name3',
		desc: 'long description 3',
		show: false,
	},
];


	function App() {



	const [notes, setNotes] = useState(initNotes);
	
	function doSmth (id){
setNotes(notes.map(note=>{
	if(note.id===id){
	note.show=!note.show
	return note}
return note}))
} 

	
	const result = notes.map((note) => {
		let text
		if(note.show){text = note.desc}
		
		return <p key={note.id}>
			{note.name}, 
			<i>{text}</ i> 
		
		<button onClick={()=>doSmth(note.id)}>Button</button>
		</p>;
	});
	
	return <div>
		{result}
	</div>;
}
export default App





									Введение в компоненты React

Любой сайт состоит из набора независимых блоков: хедер, сайдбары, футер, контент. Можно сказать, что эти блоки и есть компоненты в том смысле, в котором подразумевается в React.

Если посмотреть на тот же хедер, что в нем можно выделить блок с логотипом, блок контактов, блок с меню и так далее. То есть компоненты могут состоять из других подкомпонентов.

Аналогичным образом дело обстоит в React - сайт строится из набора компонентов, которые в свою очередь могут содержать другие компоненты.

В React каждый компонент представляет собой отдельный модуль. Обычно разработка начинается с главного компонента App, который содержит в себе остальные.

Чтобы создавать новые компоненты.

Пусть для примера нам нужен компонент, выводящий данные продукта. Для этого нам нужно в рабочей папке создать файл Product.js и добавить в него следующий код:

import React from 'react';

function Product() {
	return <p>
		product
	</p>;
}

export default Product;

Давайте теперь выведем наш созданный компонент в компоненте App. Пусть сейчас наш App имеет следующий код:

import React from 'react';

function App() {
	return <div>
		text
	</div>;
}

export default App;

Для начала нам нужно импортировать созданный нами компонент с продуктом:

import React from 'react';
import Product from './Product'; 
	// импортируем продукт 

function App() {
	return <div>
		text
	</div>;
}

export default App;

После такого импорта внутри компонента App можно использовать компонент Product. 



								Использование компонентов в React

Каждому подключенному компоненту соответствует свой JSX тег. К примеру, у нас есть компонент Product, а значит ему соответствует тег <Product />.

Название тега компонента обязательно следует писать с большой буквы, чтобы React мог отличить вызов компонента от использования тега HTML.

Итак, давайте внутри компонента App используем компонент Product, написав соответствующий ему тег:
import React from 'react';
import Product from './Product';

function App() {
	return <div>
		<Product />
	</div>;
}

export default App;

В результате после рендиренга получится следующее:
<div>
	<p>
		product
	</p>
</div>



					Несколько экземляров компонента в React

Можно вставить несколько продуктов. Для этого нужно просто написать несколько тегов компонента:

import React from 'react';
import Product from './Product';

function App() {
	return <div>
		<Product />
		<Product />
		<Product />
	</div>;
}

export default App;

В результате после рендиренга получится следующее:
<div>
	<p>
		product
	</p>
	<p>
		product
	</p>
	<p>
		product
	</p>
</div>




								Пропсы компонентов в React


Пусть, к примеру, каждый продукт должен иметь название и цену. Сделаем так, чтобы каждый вызов тега с продуктом выводил продукт со своим именем и ценой, оформленными в нужную нам верстку.

1. при вызове тега с продуктом мы в этот тег будем писать два атрибута: атрибут name с названием продукта и атрибут cost с ценой, вот так:

function App() {
	return <div>
		<Product name="product1" cost="100" />
		<Product name="product2" cost="200" />
		<Product name="product3" cost="300" />
	</div>;
}

2. Имена и значения этих атрибутов будут попадать в виде объекта в первый параметр функции-конструктора нашего компонента Product:
function Product(props) {
	console.log(props); // объект 
		с ключами name и cost 
	
	return <p>
		product
	</p>;
}

Имя параметра может быть каким угодно, но в React принято называть его props. Фактически это не просто имя параметра, а важная концепция React.

Суть этой концепции в следующем: при вызове тега компонента в этот тег можно записывать атрибуты с данными. Эти данные будут попадать в пропсы компонента. Затем компонент может использовать эти данные, например, для создания нужной верстки.

Давайте сделаем это:

function Product(props) {
	return <p>
		name: <span>{props.name}</span>,
		cost: <span>{props.cost}</span>
	</p>;
}

Более удобно и более принято не пользоваться объектом props, а сразу выполнять дестуктуризацию пропсов прямо в параметрах функции:

function Product({ name, cost }) {
	return <p>
		name: <span>{name}</span>,
		cost: <span>{cost}</span>
	</p>;
}




					Создание дочерних компонентов в React

В атрибуты тегов компонента можно передавать не только строки, но и выполнять вставку переменных и констант:
function App() {
	const name = 'product';
	const cost = '100';
	
	return <div>
		<Product name={name} cost={cost} />
	</div>;
}

Давайте сделаем сразу несколько продуктов:
function App() {
	const name1  = 'product1';
	const cost1 = '100';
	
	const name2  = 'product2';
	const cost2 = '100';
	
	const name3  = 'product3';
	const cost3 = '100';
	
	return <div>
		<Product name={name1} cost={cost1} />
		<Product name={name2} cost={cost2} />
		<Product name={name3} cost={cost3} />
	</div>;
}


			Массив для создания дочерних компонентов в React

Пусть у нас есть массив с продуктами:
const prods = [
	{id: id(), name: 'product1', cost: 100},
	{id: id(), name: 'product2', cost: 200},
	{id: id(), name: 'product3', cost: 300},
];

Давайте выведем на экран три компонента Product, передав им в пропсы данные из нашего массива. Пока не будем использовать цикл, а просто будем обращаться к элементам массива и объекта:
function App() {
	return <div>
		<Product name={prods[0].name} cost={prods[0].cost} />
		<Product name={prods[1].name} cost={prods[1].cost} />
		<Product name={prods[2].name} cost={prods[2].cost} />
	</div>;
}



				Дочерние компоненты в цикле React

Давайте теперь выведем наши компоненты в цикле. Используем для этого метод map:
function App() {
	const result = prods.map(prod => {
		return <Product name={prod.name} 
			cost={prod.cost} />; 
	});
	
	return <div>
		{result}
	</div>;
}

Не забудем указать атрибут key:
function App() {
	const result = prods.map(prod => {
		return <Product key={prod.id} name={prod.name} 
			cost={prod.cost} />; 
	});
	
	return <div>
		{result}
	</div>;
}



			Передача стейтов в дочерние компоненты в React

Пусть у нас дан массив с продуктами:

const initProds = [
	{id: id(), name: 'product1', cost: 100},
	{id: id(), name: 'product2', cost: 200},
	{id: id(), name: 'product3', cost: 300},
];

Пусть этот массив располагается в компоненте Products. Запишем эти продукты в состояние компонента:
function Products() {
	const [prods, setProds] = useState(initProds);
}

Теперь давайте переберем продукты циклом и выведем их в какой-нибудь верстке:
function Products() {
	const [prods, setProds] = useState(initProds);
	
	const items = prods.map(prod => {
		return <div key={prod.id}>
			name: <span>{prod.name}</span>,
			cost: <span>{prod.cost}</span>
		</div>;
	});
	
	return <div>
		{items}
	</div>;
}

Как вы видите, содержимое нашего цикла map достаточно сложное, особенное если верстка продукта разрастется в дальнейшем. Такая сложность затрудняет чтение, понимание и поддержку кода.

Будет лучше вынести код, отвечающий за отображение продукта в отдельный компонент. Назовем его Product. Вот код нашего компонента:
function Product({ name, cost }) {
	return <div>
		name: <span>{name}</span>,
		cost: <span>{cost}</span>
	</div>;
}

Давайте теперь внутри компонента Products в цикле map будем использовать дочерние компоненты Product:
function Products() {
	const [prods, setProds] = useState(initProds);
	
	const items = prods.map(prod => {
		return <Product
			key ={prod.id}
			name={prod.name}
			cost={prod.cost}
		/>;
	});
	
	return <div>
		{items}
	</div>;
}

Как вы видите, теперь код цикла упростился и стал более понятым для понимания. Кроме того, теперь за отображение продукта отвечает отдельный компонент, в котором мы можем делать, а потом редактировать верстку продуктов.

Технически у нас получается, что родительский компонент имеет стейт с данными, а дочерние компоненты получают эти данные в виде пропсов и отображают их нужным нам образом. 



					Передача id в компонент в React

Вы уже знаете, что атрибуты тега компонента попадают в пропсы. Это касается всех атрибутов, кроме атрибута key, который нужен для использования в циклах, вот так:
const items = prods.map(prod => {
	return <Product
		key ={prod.id}
		name={prod.name}
		cost={prod.cost}
	/>;
});

В данном случае в пропсы попадут атрибуты name и cost, а key - не попадет. Нам, однако, может понадобится передать id в пропсы компонента. В этом случае нам нужно будет ввести еще один атрибут:
const items = prods.map(prod => {
	return <Product
		key ={prod.id}
		id  ={prod.id}
		name={prod.name}
		cost={prod.cost}
	/>;
});



		Изменение стейта родителя в дочернем компоненте в React

В предыдущем уроке у нас стейт с данными хранился в родительском компоненте, а дочерние компоненты получали эти данные в виде пропсов.

Пусть теперь мы хотим изменять наши продукты. Сделаем, к примеру, кнопку, которая будет помещать наш продукт в корзину. Для начала давайте добавим в наш массив с продуктами поле inCart, показывающее, в корзине продукт или нет:
const initProds = [
	{id: id(), name: 'product1', cost: 100, inCart: false},
	{id: id(), name: 'product2', cost: 200, inCart: false},
	{id: id(), name: 'product3', cost: 300, inCart: false},
];

В компоненте Products в тег с продуктом добавим еще один атрибут inCart:
function Products() {
	const [prods, setProds] = useState(initProds);
	
	const items = prods.map(prod => {
		return <Product
			key   ={prod.id}
			name  ={prod.name}
			cost  ={prod.cost}
			inCart={prod.inCart}
		/>;
	});
	
	return <div>
		{items}
	</div>;
}

Давайте в дочернем компоненте Product сделаем вывод информации о корзине и кнопку для добавления в корзину:
function Product({ id, name, cost, inCart }) {
	return <div>
		name: <span>{name}</span>,
		cost: <span>{cost}</span>,
		<span>{inCart ? 'in cart' : 'not in cart'}</span>
		<button>to cart</button>
	</div>;
}
Реализуем добавление

По правилам React компонент не должен изменять свои пропсы. Это значит, что дочерний компонент не может положить сам себя в корзину, изменив пропс inCart. Это не правильно.

Правильно будет попросить родительский компонент изменить свой стейт prods, положив определенный продукт в корзину.

Давайте посмотрим, как это делается.

В компоненте-родителе сделаем функцию addToCart, которая параметром принимает id продукта и для этого продукта меняет свойство inCart на true:
function addToCart(id) {
	setProds(prods.map(prod => {
		if (prod.id === id) {
			prod.inCart = true;
		}
		
		return prod;
	}));
}

В тег с продуктом добавим атрибут, в который передадим созданную нами функцию, а также атрибут, в который передадим id продукта:
const items = prods.map(prod => {
	return <Product
		key      ={prod.id}
		id       ={prod.id}
		name     ={prod.name}
		cost     ={prod.cost}
		inCart   ={prod.inCart}
		addToCart={addToCart}
	/>;
});

Как вы видите, в пропсы компонентов можно передавать не только какие-то данные, но и функции.

Итоговый код класса Products получится следующим:
function Products() {
	const [prods, setProds] = useState(initProds);
	
	function addToCart(id) {
		setProds(prods.map(prod => {
			if (prod.id === id) {
				prod.inCart = true;
			}
			
			return prod;
		}));
	}
	
	const items = prods.map(prod => {
		return <Product
			key      ={prod.id}
			id       ={prod.id}
			name     ={prod.name}
			cost     ={prod.cost}
			inCart   ={prod.inCart}
			addToCart={addToCart}
		/>;
	});
	
	return <div>
		{items}
	</div>;
}

Теперь в дочернем классе у нас будет доступна функция addToCart. Вызовем эту функцию по клику на кнопку, передав ей параметром id продукта:
function Product({ id, name, cost, 
	inCart, addToCart }) { 
	return <div>
		name: <span>{name}</span>,
		cost: <span>{cost}</span>,
		<span>{inCart ? 'in cart' : 'not in cart'}</span>
		<button onClick={() => addToCart(id)}>to cart</button>
	</div>;
}

Получится, что по клику на кнопку в потомке вызовется функция родителя, которая и поменяет родительский стейт. Изменение родительского стейта вызовет перерендеринг и перересует наш продукт, передав ему измененный пропс. 




			Редактирование стейта родителя в дочернем компоненте

Давайте теперь будем редактировать наши продукты с помощью инпутов. Для этого в дочернем компоненте сделаем кнопку.

По первому нажатию на эту кнопку пусть вместо названия и цены с продуктом появятся инпуты для их редактирования, а по второму нажатию вместо инпутов опять появятся тексты.

Внесем изменение в массив с продуктами, добавив свойство isEdit (а работу с корзиной для простоты уберем):
const initProds = [
	{id: id(), name: 'product1', cost: 100, isEdit: false},
	{id: id(), name: 'product2', cost: 200, isEdit: false},
	{id: id(), name: 'product3', cost: 300, isEdit: false},
];

Компонент Product

Сделаем в продукте кнопку для редактирования:
function Product({ id, name, cost, isEdit }) {
	return <div>
		name: <span>{name}</span>
		cost: <span>{cost}</span>
		<button>edit</button>
	</div>;
}

Сделаем так, чтобы по клику на эту кнопку вызвалась некоторая функция toggleMode, переданная из родительского компонента:
function Product({ id, name, cost, 
	isEdit, toggleMode }) { 
	return <div>
		name: <span>{name}</span>
		cost: <span>{cost}</span>
		
		<button onClick={() => toggleMode(id)}>
			edit
		</button>
	</div>;
}

Пока у нас нет реализации toggleMode, но мы знаем, что она будет располагаться в компоненте-родителе, параметром принимать id продукта и изменять свойство isEdit продукта на противоположное.

Сделаем также так, чтобы текст кнопки менялся каждое нажатие:

function Product({ id, name, cost, 
	isEdit, toggleMode }) { 
	return <div>
		name: <span>{name}</span>
		cost: <span>{cost}</span>
		
		<button onClick={() => toggleMode(id)}>
			{isEdit ? 'save': 'edit'}
		</button>
	</div>;
}

Давайте теперь сделаем так, чтобы в режиме редактирования у нас были инпуты с данными, а в обычном режиме - спены:
function Product({ id, name, cost, 
	isEdit, toggleMode }) { 
	return <div>
		name: {isEdit ? <input value={name} 
			/> : <span>{name}</span>} 
		cost: {isEdit ? <input value={cost} 
			/> : <span>{cost}</span>} 
		
		<button onClick={() => toggleMode(id)}>
			{isEdit ? 'save': 'edit'}
		</button>
	</div>;
}

Привяжем к нашим инпутам событие onChange, в котором будем вызывать некоторую родительскую функцию editProd:
function Product({ id, name, cost, 
	isEdit, toggleMode, editProd }) { 
	return <div>
		name: {
			isEdit
			? <input value={name} onChange={event 
				=> editProd(id, 'name', event)} /> 
			: <span>{ name }</span>
		}
		cost: {
			isEdit
			? <input value={cost} onChange={event 
				=> editProd(id, 'cost', event)} /> 
			: <span>{ cost }</span>
		}
		
		<button onClick={() => toggleMode(id)}>
			{isEdit ? 'save': 'edit'}
		</button>
	</div>;
}
Компонент Products

Давайте теперь перейдем в компонент Products. Реализуем в нем функцию toggleMode:
function toggleMode(id) {
	setProds(prods.map(prod => {
		if (prod.id === id) {
			prod.isEdit = !prod.isEdit;
		}
		
		return prod;
	}));
}

Также реализуем в нем функцию editProd:
function editProd(id, field, event) {
	setProds(prods.map(prod => {
		if (prod.id === id) {
			prod[field] = event.target.value;
		}
		
		return prod;
	}));
}

В тег с продуктом атрибутами передадим наши функции toggleMode и editProd:
const items = prods.map(prod => {
	return <Product
		key ={prod.id}
		id  ={prod.id}
		name={prod.name}
		cost={prod.cost}
		isEdit={prod.isEdit}
		toggleMode={toggleMode}
		editProd={editProd}
	/>;
});

Окончательный код компонента Products получится следующим:
function Products() {
	const [prods, setProds] = useState(initProds);
	
	function toggleMode(id) {
		setProds(prods.map(prod => {
			if (prod.id === id) {
				prod.isEdit = !prod.isEdit;
			}
			
			return prod;
		}));
	}
	
	function editProd(id, field, event) {
		setProds(prods.map(prod => {
			if (prod.id === id) {
				prod[field] = event.target.value;
			}
			
			return prod;
		}));
	}
	
	const result = prods.map(prod => {
		return <Product
			key ={prod.id}
			id  ={prod.id}
			name={prod.name}
			cost={prod.cost}
			isEdit={prod.isEdit}
			toggleMode={toggleMode}
			editProd={editProd}
		/>;
	});
	
	return <div>
		{result}
	</div>;
}



			Редактирование стейта во внучатом компоненте

Рассмотрим компонент Product, полученный нами в предыдущем уроке:
function Product({ id, name, cost, 
	isEdit, toggleMode, editProd }) { 
	return <div>
		name: {
			isEdit
			? <input value={name} onChange={event 
				=> editProd(id, 'name', event)} /> 
			: <span>{name}</span>
		}
		cost: {
			isEdit
			? <input value={cost} onChange={event 
				=> editProd(id, 'cost', event)} /> 
			: <span>{cost}</span>
		}
		
		<button onClick={() => toggleMode(id)}>
			{isEdit ? 'save': 'edit'}
		</button>
	</div>;
}

Легко заметить, что код для названия продукта и для цены продукта практически дублируется. Давайте вынесем этот код в отдельный компонент ProductField:
function ProductField({ id, text, 
	type, isEdit, editProd }) { 
	return isEdit
		? <input value={text} onChange={event 
			=> editProd(id, type, event)} /> 
		: <span>{text}</span>
	;
}

Внесем изменения в компонент Product:
function Product({ id, name, cost, 
	isEdit, toggleMode, editProd }) { 
	return <div>
		name: <ProductField
			id={id}
			text={name}
			type="name"
			isEdit={isEdit}
			editProd={editProd}
		/>,
		
		cost: <ProductField
			id={id}
			text={cost}
			type="cost"
			isEdit={isEdit}
			editProd={editProd}
		/>
		
		<button onClick={() => toggleMode(id)}>
			{isEdit ? 'save': 'edit'}
		</button>
	</div>;
}



		Режимы работы через стейты компонентов-потомков

Пусть наш массив с продуктами теперь выглядит следующим образом:
const initProds = [
	{id: id(), name: 'prod1', cost: 'cost1', catg: 'catg1'},
	{id: id(), name: 'prod2', cost: 'cost2', catg: 'catg2'},
	{id: id(), name: 'prod3', cost: 'cost3', catg: 'catg3'},
];

Давайте выведем эти продукты в виде HTML таблицы. При этом сделаем так, чтобы по нажатию на любую ячейку таблицы в этой ячейке появлялся инпут для редактирования. Для решения задачи сделаем 3 компонента.

Компонент Products будет хранить стейт с продуктами и использовать компоненты Product для вывода продуктов. Компонент Product в свою очередь также будет использовать компоненты ProductField для вывода определенного поля продукта (названия, цены, категории).

Компонент ProductField будет либо показывать текст поля, либо инпут для его редактирования. При этом режим редактирования или показа пусть регулируется стейтом данного компонента.

То есть мы не будем хранить режим в родительском стейте. Там это было бы очень неудобно, так как нам пришлось бы указывать режим для каждого поля продукта, что превратило бы наш стейт в нечто подобное:
const initProds = [
	[
		{field: 'name', value: 'prod1', isEdit: false},
		{field: 'cost', value: 'cost1', isEdit: false},
		{field: 'catg', value: 'catg1', isEdit: false},
	],
	[
		{field: 'name', value: 'prod2', isEdit: false},
		{field: 'cost', value: 'cost2', isEdit: false},
		{field: 'catg', value: 'catg2', isEdit: false},
	],
	[
		{field: 'name', value: 'prod3', isEdit: false},
		{field: 'cost', value: 'cost3', isEdit: false},
		{field: 'catg', value: 'catg3', isEdit: false},
	],
]

Мы, однако, не будем делать такой стейт, а оставим тот, который был. Просто каждый экземпляр компонента ProductField с помощью своего стейта будет регулировать режим: либо редактирование, либо показ.

Таким образом получится, что родительский компонент будет хранить стейт с данными, а наш внучатый компонент будет получать эти данные через пропсы и при этом будет иметь свой стейт для изменения своего режима.

Итак, давайте реализуем описанное.
Компонент Products
function Products() {
	const [prods, setProds] = useState(initProds);
	
	function changeField(id, field, event) {
		setProds(prods.map(prod => {
			if (prod.id === id) {
				prod[field] = event.target.value;
			}
			
			return prod;
		}));
	}
	
	const rows = prods.map(prod => {
		return <Product
			key ={prod.id}
			id  ={prod.id}
			name={prod.name}
			cost={prod.cost}
			catg={prod.catg}
			changeField={changeField}
		/>;
	});
	
	return <div>
		<table>
			<tbody>
				{rows}
			</tbody>
		</table>
	</div>;
}
Компонент Product
function Product({ id, name, cost, 
	catg, changeField }) { 
	return <tr>
		<ProductField id={id} text={name} 
			type="name" changeField={changeField} /> 
		<ProductField id={id} text={cost} 
			type="cost" changeField={changeField} /> 
		<ProductField id={id} text={catg} 
			type="catg" changeField={changeField} /> 
	</tr>;
}
Компонент ProductField
function ProductField({ id, text, 
	type, changeField }) { 
	const [isEdit, setIsEdit] = useState(false);
	
	return <td>
		{
			isEdit
			? <input
				value={text}
				onChange={event => changeField(id, type, event)}
				onBlur={() => setIsEdit(false)}
			/>
			: <span onClick={() => setIsEdit(true)}>{text}</span>
		}
	</td>;
}



			Концепции React при работе с компонентами

1)Данные компонентов в React

Данные компонентов могут хранится в трех местах: в пропсах, в переменных и константах компонента, и в стейтах. В пропсах хранятся данные, которые посылает компоненту извне его родительский компонент. При этом внутри компонента пропсы должны оставаться неизменными.
 
В переменных, константах и стейтах следует хранить локальные данные, которые важны лично компоненту и о которых не следует знать родителю. При этом в стейтах следует хранить данные, которые могут изменяться в различных событиях и при этом вы хотите, чтобы изменения были реактивными.

Дан некий компонент:
function Test() {
	// определение isEdit, elem и data
	
	if (isEdit) {
		elem = <input value={data} />;
	} else {
		elem = <span>{data}</span>;
	}
	
	return <div>
		{elem}
	</div>;
}

Определите, чем могут быть isEdit, elem и data: пропсом, стейтом, переменной, либо константой. 

2)Типы компонентов

Компоненты в React рекомендовано разбивать на два типа: компоненты-контейнеры (умные, толстые) и презентационные (глупые, худые).

Презентационные компоненты предназначены для отображения данных в HTML верстке. При этом такие компоненты не должны иметь стейтов (кроме стейтов, регулирующих режим работы компонента), а данные в них должны передаваться извне с помощью пропсов. То есть такие компоненты просто получают данные из своего родителя и отображают их в нужном виде.

Компоненты-контейнеры как правило содержат в себе стейты с данными, но сами не отображают эти данные, а используют для этого дочерние презентационные компоненты. При этом контейнеры можно вкладывать друг в друга. То есть компонент-контейнер может содержать как презентационные компоненты, так и контейнеры, в свою очередь содержащие презентационные компоненты.

Преимущество такого подхода в легком переиспользовании презентационных компонентов, так как такие компоненты не знают, откуда берутся данные, а просто отображают их. Это значит, что один и тот же компонент мы можем использовать в разных ситуациях, передавая ему данные из разных источников. 


3)Однонаправленный поток данных

Компонент может передавать свое состояние вниз по дереву потомков в виде пропсов дочерних компонентов. Этот процесс называется нисходящим (англ. top-down) или однонаправленным (англ. unidirectional) потоком данных. Состояние всегда принадлежит определенному компоненту, и это состояние может влиять только на компоненты, являющиеся потомками данного компонента.

Кроме нисходящего потока данных, существует также восходящий или обратный. Он содержит в себе данные, которые появляются в компонентах-потомках, например, вводятся в инпуты пользователем. Этот поток данных передается родителю путем вызова функции, переданной в пропсы дочернего компонента. 

4) Подъем состояний в React

Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. В React рекомендовано поднимать общее состояние до ближайшего общего предка. Давайте посмотрим на примере.

Пусть мы хотим сделать калькулятор температуры воды. Он будет представлять собой инпут, в который пользователь будет вводить температуру, и абзац, в который будет выводится вердикт: вода жидкая, вода твердая, вода газообразная.

Пусть наш калькулятор представляет собой компонент-контейнер Calculator:
function Calculator() {
	return <div>
		
	</div>;
}

Вынесем инпут для ввода температуры в компонент TempInp, а абзац с вердиктом - в компонент Verdict:
function Calculator() {
	return <div>
		<Verdict />
		<TempInp />
	</div>;
}

Легко понять, что и TempInp, и Verdict должны иметь стейт с температурой. При этом логично, что это должна быть одна и та же температура: по мере ввода данных в инпут должен отображаться вердикт.

В таком случае рекомендовано использовать прием, называемый подъем состояния: состояние, общее для двух (и более) компонентов поднимается вверх до их общего родителя.

В нашем случае получится, что стейт с температурой должен принадлежать компоненту Calculator, который будет передавать его в TempInp и Verdict в качестве пропсов:

function Calculator() {
	const [temp, setTemp] = useState(0);
	
	return <div>
		<Verdict temp={temp} />
		<TempInp temp={temp} />
	</div>;
}

 передать в дочерний компонент функцию setTemp:
function Calculator() {
	const [temp, setTemp] = useState(0);
	
	return <div>
		<Verdict temp={temp} />
		<TempInp temp={temp} setTemp={setTemp} />
	</div>;
}  


5) Один источник истины

 Для любых изменяемых данных в React-приложении должен быть один источник истины. Под этими словами имеется ввиду то, что если у вас есть два стейта и один стейт может быть вычислен через другой - значит один из стейтов лишний и его нужно убрать.

Давайте обсудим это на примере. Пусть у вас, к примеру, есть два инпута: в первый вводится температура в градусах Фаренгейта, а во второй - в градусах Цельсия. При этом мы хотим, чтобы оба инпута были синхронизированы: при вводе температуры в один инпут она соответствующим образом должна меняться во втором.

Неправильным подходом будет ввести два стейта: один для температуры по Фаренгейту, а второй - по Цельсию. Почему не правильно: потому что одна температура вычисляется из другой, а значит в качестве места хранения данных должен быть один стейт. 





				Способы стилизации React компонентов


1)Стандартный подход, который мы можем применить, как и при обычной стилизации веб-страниц - это использование глобального CSS. Тут мы создаем один внешний общий CSS файл со стилями. При таком подходе, все имена классов находятся в глобальной области видимости, что может приводить к конфликтам между ними. Также можно сделать множество маленьких CSS файлов. Этот подход малоэффективен при создании больших масштабируемых приложений.

Предположим, у нас есть React компонент App, в котором есть див, а внутри дива - три абзаца:

function App() {
	return (
		<div>
			<p>text</p>
			<p>text</p>
			<p>text</p>
		</div>
	);
}

Давайте стилизуем этот компонент. Для этого, в той же папке src с нашим компонентом создадим обычный CSS файл со стилями styles.css для наших тегов.

В этом файле для дива создадим класс class1 со стилями:
.class1 {
	width: 200px;
	border: 2px solid brown;
	padding: 10px;
	text-align: center;
}

Теперь добавим класс class2 со стилями для первого абзаца:
.class2 {
	color: orangered;
	font-weight: bold;
}

Класс class3 со стилями для второго абзаца:
.class3 {
	font-style: italic;
	color: brown;
}

И, наконец создадим класс class4 для последнего абзаца:
.class4 {
	background-color: orange;
	font-weight: bold;
	color: white;
}		 

Нужно применить CSS стили, которые мы написали для тегов. Вернемся к  файлу App.js с компонентом.

Первое, что мы должны обязательно сделать - добавить в начало файла строку импорта нашего файла стилей styles.css:
import './styles.css';

Теперь, чтобы применить в компоненте CSS классы из файла, воспользуемся атрибутом class. Для первого абзаца у нас был класс class2, применим его:
<p class="class2">text</p>

Подобным образом добавим классы для остальных тегов. В результате получим следующий код:
<div class="class1">
	<p class="class2">text</p>
	<p class="class3">text</p>
	<p class="class4">text</p>
</div>			 


2)Следующий подход - инлайновая стилизация, используя его, мы можем добавить CSS стили инлайн, подобно тому, как это делается в обычном HTML. В этом случае мы будем работать с атрибутом style, передавая ему необходимые CSS свойства. Применение такой стилизации считается плохим тоном и рекомендуется только для добавления динамически вычисляемых во время рендеринга стилей. Этот способ хорош для быстрого прототипирования интерфейса отдельного компонента.

 CSS стили элементам можно также добавлять и с помощью атрибута style. В этом и нескольких последующих уроках мы рассмотрим способы инлайновой стилизации.

Теперь мы не будем подключать файл styles.css, а передадим соответствующие значения в атрибут style в виде объекта со стилями для каждого тега, которые мы будем писать прямо в файле компонента.

Итак, возьмем наш компонент без CSS стилей, который мы делали на прошлом уроке:
function App() {
	return (
		<div>
			<p>text</p>
			<p>text</p>
			<p>text</p>
		</div>
	);
}

Давайте в файле App.js перед командой return создадим объект с CSS стилями для дива в переменной class1. Помните, что названия свойств здесь пишутся в camelCase нотации, а значения свойств нужно взять в кавычки:
const class1 = {
	width: '200px',
	border: '2px solid brown',
	padding: '10px',
	textAlign: 'center'
};

и по аналогии с другими

Теперь, чтобы применить в компоненте CSS классы, воспользуемся атрибутом style. Для первого абзаца у нас была переменная class2, передадим ее в качестве значения:
<p style={class2}>text</p>

Подобным образом добавим стили из объектов для остальных тегов.

В результате, код компонента будет выглядеть следующим образом:
function App() {
	const class1 = {
		width: '200px',
		border: '2px solid brown',
		padding: '10px',
		textAlign: 'center',
	};

	const class2 = {
		color: 'orangered',
		fontWeight: 'bold',
	};

	const class3 = {
		fontStyle: 'italic',
		color: 'brown',
	};

	const class4 = {
		backgroundColor: 'orange',
		fontWeight: 'bold',
		color: 'white',
	};

	return (
		<div style={class1}>
			<p style={class2}>text</p>
			<p style={class3}>text</p>
			<p style={class4}>text</p>
		</div>
	);
} 

 ! Мы можем не писать объекты со стилями в файле с компонентом, как в прошлом уроке, а создать отдельный файл с нашими объектами стилей и импортировать их в нужный компонент.

Итак, возьмем наш компонент без CSS стилей:
function App() {
	return (
		<div>
			<p>text</p>
			<p>text</p>
			<p>text</p>
		</div>
	);
}

Давайте создадим в папке src отдельный файл styles.js, в котором пропишем наши объекты со стилями:
const class1 = {
	width: '200px',
	border: '2px solid brown',
	padding: '10px',
	textAlign: 'center',
};

и другие
};

Не забудем внизу файла styles.js экспортировать наши объекты одним объектом styles:
export const styles = {
	class1: class1,
	class2: class2,
	class3: class3,
	class4: class4
};

Теперь импортируем объект styles в наш компонент:
import { styles } from "./styles";			 

Теперь мы можем применять нужный нам объект с CSS стилями из общего объекта styles к нашим тегам. Применим к первому абзацу стили из объекта class2:
<p style={styles.class2}>text</p>

Подобным образом добавим стили из объектов остальным тегам.

В результате, код компонента будет выглядеть следующим образом:
function App() {
	return (
		<div style={styles.class1}>
			<p style={styles.class2}>text</p>
			<p style={styles.class3}>text</p>
			<p style={styles.class4}>text</p>
		</div>
	);
}  

! Можно не использовать промежуточную переменную, а расписать объект прямо в атрибуте - в этом случае нам нужны две пары фигурных скобок - первая от JSX вставки, а вторая - от объекта.

Итак, возьмем наш компонент без CSS стилей:
function App() {
	return (
		<div>
			<p>text</p>
			<p>text</p>
			<p>text</p>
		</div>
	);
}

К примеру, пропишем напрямую CSS свойства для первого абзаца нашего React компонента App:
<p style = {{
	color: 'orangered',
	fontWeight: 'bold' }}>
	text
</p>
3)применение библиотеки Styled Components, которая использует для стилизации шаблонные строки. Этот метод позволяет нам писать обычный CSS в JS коде, используя весь его функционал.

 Для начала установим библиотеку Styled Components:
npm install --save styled-components

Затем импортируем необходимый нам пакет в компонент App:
import styled from 'styled-components';

Теперь мы можем оборачивать теги в стили и применять их как React компоненты, но уже с прикрепленными прямо в JS стилями. Такой подход еще называют CSS в JS.

Давайте стилизуем первый абзац. Для этого перед функцией App после строк импорта создадим компонент Text1. В объекте styled из библиотеки нам нужен абзац, поэтому мы пишем styled.p. Затем, в шаблонной строке перечисляем необходимые нам CSS стили - как в обычном CSS:
const Text1 = styled.p`
	color: orangered;
	font-weight: bold;
`;

Как видите, мы используем здесь чистый CSS в виде шаблонных строк, что очень удобно. Подобным образом мы можем использовать медиа-запросы, псевдоэлементы, селекторы и другой функционал CSS.

Теперь внутри функции компонентa App заменим тег p на созданный нами компонент Text1 с CSS стилями:
<Text1>text</Text1>	   

Подобным образом стилизуем второй и третий абзацы. Для этого создадим компоненты Text2 и Text3:
const Text2 = styled.p`
	font-style: italic;
	color: brown;
`;

const Text3 = styled.p`
	background-color: orange;
	font-weight: bold;
	color: white;
`;

И, наконец, стилизуем наш див. Для этого создадим компонент и назовем его Container:
const Container = styled.div`
	width: 200px;
	border: 2px solid brown;
	padding: 10px;
	text-align: center;
`;

Выведем контейнеры

function App() {
	return (
		<Container>
			<Text1>text</Text1>
			<Text2>text</Text2>
			<Text3>text</Text3>
		</Container>
	);
}

 Благодаря такому подходу можно создавать многократно используемые компоненты со стилями.

Если вы откроете сгенерированную верстку в панели разработчика в браузере, то вы увидите, что у каждого компонента сгенерированы свои уникальные классы. Таким образом, нам не нужно больше беспокоиться о конфликтах между классами отдельных компонентов.

Подобным образом можно стилизовать компоненты, используя, к примеру, библиотеку Emotion. 

!!!  Использование пропсов с Styled Components в React

Из прошлого урока мы узнали, что стилизованные при помощи библиотеки Styled Components компоненты можно использовать как обычные React компоненты. В данном уроке мы увидим, что здесь подобным образом будут работать и пропсы.

Предположим у нас есть React компонент Block и мы создали в нем стилизованные при помощи Styled Components компоненты Input и Container:
const Container = styled.div`
	display: flex;
	flex-direction: column;
	width: 150px;
`;

const Input = styled.input`
	margin: 5px;
	font-size: 18px;
`;

Расположим три компонента Input в Container:
function Block() {
	return (
		<Container>
			<Input />
			<Input />
			<Input />
		</Container>
	);
}

Используя пропсы, мы можем устанавливать в компонентах различные атрибуты. Давайте установим второму инпуту атрибуты placeholder и type со значениями name и text, соответственно, а третьему инпуту у атрибута type установим значение password:
function Block() {
	return (
		<Container>
			<Input />
			<Input placeholder="name" type="text" />
			<Input type="password" />
		</Container>
	);
}


!!! Использование пропсов в условном рендеринге с Styled Components в React

Пропсы можно использовать и для условного рендеринга. Возьмем React компонент Block, с которым мы работали на прошлом уроке.

Сделаем так, чтобы у нас фон для первого инпута был желтым, а для других инпутов зеленым. Для этого, в стили для компонента Input добавим еще строчку и получится:
const Input = styled.input`
	background: ${(props) => (props.first ? '
		yellow' : 'green')};

	m argin: 5px;
	font-size: 18px;
`;

Добавим пропс first первому инпуту:
<Container>
	<Input first />
	<Input placeholder="name" type="text" />
	<Input type="password" />
</Container>

!!!!

Расширенная стилизация компонентов в React

Предположим у нас есть React компонент Block и мы создали в нем стилизованные при помощи Styled Components компоненты Button и Container:
const Container = styled.div`
	display: flex;
	flex-direction: column;
	width: 150px;
`;

const Button = styled.input`
	background-color: orange;
	font-size: 18px;
	margin: 5px;
`;

А теперь представим, что нам нужен еще один компонент Button, только с белым текстом кнопки и зеленым фоном.

Для этого нам достаточно на базе нашего компонента Button создать новый компонент MdButton и прописать в нем только те свойства, которые мы хотим изменить:
const MdButton = styled(Button)`
	color: white;
	background-color: green;
`;

Расположим в Block все наши стилизованные компоненты:
function Block() {
	return (
		<Container>
			<Button>btn0</Button>
			<MdButton>btn1</MdButton>
		</Container>
	);
}
4)применение CSS модулей. В данном случае, CSS модуль - это такой CSS файл, в котором по умолчанию все названия классов и анимаций находятся в локальной области видимости, то есть доступны только внутри компонента, который его использует.

В этих двух последних способах мы можем не бояться конфликтов между именами классов, ведь они уникальны - используется концепция локальной области видимости. Также при их использовании отпадает необходимость в методологии БЭМ.

Для начала создадим и запустим наше простенькое React приложение buttons. Для этого создадим пустую папку test, зайдем в нее и в терминале напишем следующие команды:
npx create-react-app buttons
cd buttons
npm start

Наше приложение для стилизации способом CSS modules будет содержать три кнопочки.

CSS файлы мы будем называть, придерживаясь соглашения, следующим образом: [name].module.css.

Давайте сейчас создадим папку components в src, а в нее добавим файл Buttons.module.css с CSS стилями к нашим кнопкам:
.btn1 {
	background-color: orange;
	border: 2px solid brown;
	color: white;
}

.btn2 {
	background-color: red;
	border: 2px solid green;
	color: yellow;
}

.btn3 {
	background-color: brown;
	border: 2px solid yellowgreen;
	color: orange;
}

Также в папке components, создадим пустой файл React компонента Buttons.js, при этом пока не трогайте сгенерированный файл App.js, мы займемся им позже!

В Buttons.js обязательно импортируем файл с CSS стилями, а также применим эти стили к каждой кнопке с помощью атрибута class:

import styles from "./Buttons.module.css"; 

const Buttons = () => (
	<>
		<button class={styles.btn1}>btn1</button>
		<button class={styles.btn2}>btn2</button>
		<button class={styles.btn3}>btn3</button>
	</>
);

export default Buttons;

Теперь займемся главным компонентом App, который уже был сгенерирован в папке src изначально. В нем у нас будет два дива, заголовок и кнопка.

Заменим название файла App.css на App.module.css по соглашению, очистим его и создадим в нем несколько классов с CSS стилями к тегам:
.app {
	display: flex;
	flex-direction: column;
	width: 300px;
	border: 1px solid brown;
	padding: 10px;
}

.wrapper {
	display: flex;
	justify-content: space-around;
}

.title {
	text-align: center;
	margin-top: 10px;
}

А теперь очистим содержимое файла App.js. Затем импортируем React компонент Buttons и стили из App.module.css. Напишем наши теги и применим к ним стили, а также разместим React компонент Buttons:
import classes from "./App.module.css"; 
import Buttons from "./components/Buttons"; 

function App() {
	return (
		<div class={classes.app}>
			<h2 class={classes.title}>CSS Module Buttons</h2>
			<div class={classes.wrapper}>
				<Buttons />
			</div>
		</div>
	);
}
export default App;

Мы использовали слово classes для имени объекта, содержащего стили, который мы импортируем из App.module.css. Как и в предыдущем случае, вы можете назвать этот объект как вам удобно.

Осталась пара маленьких шагов. Изменим название файла index.css по соглашению на index.module.css и в файле index.js не забудем заменить строку импорта:
import "./index.css";

На строку:
import "./index.module.css";

Теперь мы можем видеть в браузере результат работы нашего приложения.

Если вы откроете сгенерированную верстку в панели разработчика в браузере, вы увидите, что у каждого компонента сгенерированы свои уникальные классы. Таким образом, нам не нужно больше беспокоиться о конфликтах между классами отдельных компонентов.

Важно еще то, что CSS modules не запрещает импортировать и обычные внешние CSS файлы.

!!!!Команду composes можно применить и для переиспользования стилей из одного файла в другом.

Вернемся к приложению buttons, которое мы делали в предыдущих уроках. Предположим, мы хотим добавить всем кнопочкам одинаковые тени, стиль курсора и жирный шрифт. Пусть эти стили будут расположены в файле App.module.css. Давайте откроем этот файл и добавим в начало новый класс beauty с этими стилями:
.beauty { 
	box-shadow: rgba(50, 50, 50, 0.2) 0 5px 5px 0;
	font-weight: bold;
	cursor: pointer;
}

Давайте применим его для стилизации кнопочек. Для этого откроем Buttons.module.css и внесем изменения в класс common-btn. Мы добавим строку с командой composes, где укажем название класса beauty, который мы хотим применить и файла App.module.css, в котором находится этот класс:
.common-btn {
	composes: beauty from "../App.module.css"; 
	font-size: 16px;
	border-radius: 3px;
}



						Хуки в React

В этом уроке мы начнем знакомиться с хуками. Мы уже сталкивались с ними, когда изучали стейты - там мы научились работать с хуком состояния useState.

В целом, хуки - это обычные JavaScript-функции, имена которых начинаются со слова 'use'.

Хуки позволяют нам использовать стейты и другие возможности React без использования классов. Они облегчают повторное использование кода для различных задач, а также его тестирование и помогают разбивать сложные компоненты на более простые функции по их назначению. Некоторые хуки даже способны заменить функционал React Redux. Ко всему прочему, хуки помогают улучшить производительность приложения.

Если вы хотите использовать хуки, то следуйте двум основным правилам. Во-первых, используйте их только на верхнем уровне - не вызывайте их внутри циклов, условных операторов или вложенных функций. Во-вторых, вызывать хуки нужно только из React-функций (из React компонентов или пользовательских хуков), но не из обычных функций JavaScript.

Также ошибкой, которую допускают программисты, является бесконтрольное использование хуков в коде. Прежде чем использовать тот или иной хук, убедитесь, что он действительно необходим.

Всего в React есть 12 встроенных хуков. Широко используемыми считаются useState, useEffect и useContext. 
Все хуки можно условно разделить на несколько групп, согласно их применению.

1)Первая группа - это хуки для работы со стейтами компонента или хуки состояния. К этой группе относятся useState и useReducer.

2)Вторая группа - это хуки контекста (понятие контекста в React мы рассмотрим в одном из уроков). В этой группе только один хук - useContext.

Обычно мы передавали данные от родительских компонентов дочерним с помощью пропсов. Этот способ хорош, если у вас немного компонентов и вам не нужно перебрасывать пропсы от родительского до нужного вам компонента через дочерние более 2-3 раз.

Данный способ также может стать крайне неудобным и привести к различным проблемам, если в промежуточных компонентах эти пропсы вообще не используются (такая проблема называется prop drilling), или вам нужно передавать одни и те же данные большому количеству компонентов.

В этих случаях нам может помочь контекст, который позволяет сделать данные родительского компонента доступными для любого дочернего, независимо от его расположения в дереве компонентов, без передачи их через пропсы. Соответственно, принимать данные будут только те компоненты, которым они нужны.

Для того, чтобы воспользоваться контекстом, его нужно создать. Для начала, создадим файл MyContext.js и импортируем в него функцию createContext:

import { createContext } from 'react';

Теперь создадим объект контекста, запишем его в переменную MyContext, которую не забудем экспортировать. В нашем случае, мы установили в createContext начальное значение null, так как нам оно непринципиально (можно было оставить просто пустые скобки). Заданное значение по умолчанию появится при чтении контекста, если не будет найдено каких-то других. Данное значение может быть любого типа:
export const MyContext = createContext(null);

В следующем уроке мы создадим приложение из нескольких компонентов, расположенных в отдельных файлах. Если бы все компоненты были в одном файле, то и для создания контекста мы не стали бы делать отдельный файл и не стали бы его экспортировать.

Давайте теперь импортируем MyContext.js в пустой компонент App - в тот компонент, из которого мы собираемся передавать данные:
import { MyContext } from './MyContext.js';

Теперь построим дерево компонентов. Для начала в отдельном файле создадим React компонент BigBox:
  
function BigBox() {
	return (
		<p>bigbox</p>
	);
}

Импортируем его и разместим в нашем главном компоненте App:
import BigBox from './BigBox';

function App() {
	return (
		<BigBox />
	);
}

Для большей наглядности немного стилизуем дивы. Для этого создадим файл styles.css:
div {
	border: 1px solid blue;
	margin: 10px;
	text-align: center;
	max-width: 300px;
}

Не забудем импортировать его в App.js:
import './styles.css';

Теперь в отдельном файле создадим компонент MiddleBox:
function MiddleBox() {
	return (
		<p>middlebox</p>
	);
}

И положим его в большую коробку BigBox:
import MiddleBox from './MiddleBox';

function BigBox() {
	return (
		<div>
			<MiddleBox />
		</div>
	);
}

Проделаем все тоже самое с маленькой коробочкой SmallBox:
function SmallBox() {
	return (
		<p>I am ... </p>
	);
}

Разместим две таких коробочки в MiddleBox:
import SmallBox from './SmallBox';

function MiddleBox() {
	return (
		<div>
			<SmallBox />
			<SmallBox />
		</div>
	);
}

Дерево мы с вами построили. А теперь мы хотим от нашего App передать, предположим, в SmallBox строковое значение 'small box :)', не используя пропсы, а пользуясь контекстом (вдруг наше коробочное приложение разрастется до огромных размеров).

Файл с контекстом MyContext.js мы уже создали и подключили на прошлом уроке.

Следующий шаг, который мы сделаем - обернем BigBox в провайдер контекста, который является свойством нашего объекта контекста MyContext. Теперь все компоненты, заключенные в данную конструкцию (а это и все коробочки, вложенные в BigBox) смогут получить доступ и подписаться на изменения контекста. В качестве значения контекста мы передаем желаемое 'small box :)':
function App() {
	return (
		<MyContext.Provider value="small box :)">
			<BigBox />
		</MyContext.Provider>
	);
}

А теперь осталось прочитать значение контекста. Мы хотели использовать его в SmallBox, значит импортируем туда файл контекста MyContext.js и хук useContext:
import { useContext } from 'react';
import { MyContext } from './MyContext.js';

Прочитаем с помощью useContext значение контекста в переменную name:
function SmallBox() {
	const name = useContext(MyContext);
	
	return (
		<div>
			<p>I am ... </p>
		</div>
	);
}

Мы подписали SmallBox на данный контекст и, если он изменится, этот компонент также будет обновлен.

И, наконец, подставляем значение переменной name вместо многоточия:
function SmallBox() {
	const name = useContext(MyContext);
	
	return (
		<div>
			<p>I am {name} </p>
		</div>
	);
}

Предположим вы захотите, чтобы контекст менялся.

В этом случае полезно применять контекст в связке со стейтами. Давайте немного изменим наше приложение с коробочками, которое мы делали на прошлом уроке и сделаем так, чтобы по нажатию на кнопку передаваемое значение стало бы 'metal box :)'.

Итак, возьмем наш файл App и после BigBox нарисуем кнопочку:
function App() {
	return (
		<MyContext.Provider value="small box :)">
			<BigBox />
			<button>click</button>
		</MyContext.Provider>
	);
}

Далее импортируем хук useState и заведем стейт name, значение которого будет меняться по нажатию кнопки. Сделаем ему начальным значением то, которое мы сразу передавали значением контекста, то есть 'small box :)':
function App() {
	const [name, setName] = useState('small box :)');
}

На этот раз контекстом мы будем передавать не строку, а стейт name:
<MyContext.Provider value={name}>
	<BigBox />
	<button>click</button>
</MyContext.Provider>

В качестве последнего шага мы будем вызывать обработчик клика по кнопке и с помощью функции setName устанавливать новое значение стейта в 'metal box :)'. После этого можно будет нажать на кнопку и проверить результат:
<button onClick={() => {
	setName('metal box :)');
}}>click</button>

3)Третья группа - это хуки рефа (с понятием рефов мы познакомимся в дальнейшем). В этой группе у нас хуки useRef и useImperativeHandle.

Реф (или ссылка) - это обычный JavaScript объект с единственным свойством current, которое вы можете читать или изменять.

Как и стейты, рефы могут хранить любой тип данных - это могут быть числа, строки, объекты и даже функции.
В целом рефы применяются там, где вам надо отступить от React и взаимодействовать с внешними API - чаще с браузерными, которые не влияют на отображение компонента. Это может быть к примеру хранение id таймера или хранение объекта, для которого не нужно вычислять JSX, но чаще всего это взаимодействие с элементами DOM. Их можно применять для управления фокусом, выделения текста или воспроизведения мультимедиа.

разберем работу хука useRef в сравнении с хуком useState.

Давайте создадим компонент с кнопкой:
return (
	<div>
		<button>
			state click
		</button>
	</div>
);

Импортируем в компонент useState:
import { useState } from 'react';

И заведем стейт state:
const [state, setState] = useState(0);

А сейчас сделаем так, чтобы по клику на кнопку наш state увеличивался бы на 1. Значение стейта будем выводить прямо в тексте кнопки:
<button onClick={handleStateClick}>
	state click: {state}
</button>

Опишем функцию для обработки клика по кнопке handleStateClick:
function handleStateClick() {
	setState(state + 1);
}

Понажимаем кнопочку и увидим, как растет значение стейта.

А сейчас давайте создадим компонент App, но используя не стейт, а реф.

Для начала, импортируем в компонент useRef:
import { useRef } from 'react';

И заведем реф ref. Своим результатом хук useRef возвращает объект рефа с единственным свойством current, которое нас и будет интересовать в дальнейшем. Установим его начальное значение в 0:
const ref = useRef(0);

Навесим на кнопочку обработчик клика. Помните, что мы должны читать/изменять не сам ref, а его свойство current:
<button onClick={handleRefClick}>
	ref click: {ref.current}
</button>

Добавим функцию для обработки клика по нашей кнопке. Здесь мы будем увеличивать current на 1, как и в предыдущем примере со стейтом. В отличие от стейта, где требуется функция setState для изменения его значения, со свойством рефа мы работаем напрямую:
function handleRefClick() {
	ref.current = ref.current + 1;
}

Теперь понажимаем нашу кнопку. И что же мы видим? При клике по ней, как у нас был изначально 0, так он и не меняется.

Вы, конечно, можете начать сомневаться в том, что значение вообще меняется. Давайте это проверим. Для этого в функции обработчика клика добавим еще строчку кода с выводом значения current в консоль:
function handleRefClick() {
	ref.current = ref.current + 1;
	console.log('ref click: ' + ref.current);
}

А сейчас, открыв консоль в браузере, снова покликаем по кнопке и убедимся, что значение действительно меняется при каждом клике и никакого обмана нет.

Теперь мы видим, что в отличие от стейта, изменение значения рефа не вызывает рендеринг компонента. Поэтому мы каждый раз в тексте кнопки видим начальное значение 0.

Таким образом, если ваши данные используются для рендеринга, то храните их в стейте, а если вам не нужен рендеринг, в таком случае использование рефов может стать более эффективным. 

4)К четвертой группе можно отнести хуки эффекта (об эффектах мы поговорим позже), такие как useEffect, useLayoutEffect, useInsertionEffect.

ффекты или побочные эффекты (англ. side effects) - это дополнительные действия, позволяющие компоненту подключаться и синхронизироваться с внешними системами.

Под внешними системами подразумеваются те кусочки кода или приложения, которые не подконтрольны React. Здесь подразумевается работа с сетью, DOM браузера, анимацией, виджетами, написанными с использованием сторонних UI библиотек, и другими приложениями, созданными не на React.

Эффекты позволяют запускать код после рендеринга, давая таким образом возможность синхронизировать ваш компонент с такими системами за пределами React.

Эффекты могут выполняться в моменты первой отрисовки компонента, в момент изменения наблюдаемого значения или когда жизненный цикл компонента закончен.

Нужно помнить, что эффекты - это своего рода "аварийный" люк из React, не стоит ими злоупотреблять. 

Для работы с эффектами применяется хук useEffect. Давайте посмотрим на его работу.

Для начала импортируем наш хук:

import { useEffect } from 'react';

Создадим компонент App, содержащий заголовок:

function App() {
	return (
		<div>
			<h1>React App</h1>
		</div>
	);
}

export default App;

Предположим, что нам надо сделать какое-то действие после рендеринга, например, установить цвет фона всей страницы. В данном случае внешней системой будет DOM браузера.

Применим наш хук:
function App() {
	useEffect(() => {
		document.body.style.backgroundColor = 'green';
	}, []);
	
	...
}

Во втором параметре передается массив зависимостей. В них входят значения, используемые функциями компонента. Пока мы оставили их пустыми. В этом случае цвет установится в зеленый только один раз после рендеринга. Совсем убрать второй параметр нельзя, так как ваш компонент может войти в бесконечный цикл. 

Теперь давайте будем менять цвет по нажатию кнопки. Заведем стейт color для цвета, задав ему начальное значение:
const [color, setColor] = useState('green');

Заменим строковое значение на наш стейт в useEffect и не забудем добавить его в список зависимостей в квадратных скобках. Теперь эффект будет выполняться каждый раз при изменении стейта color:

function App() {
	useEffect(() => {
		document.body.style.backgroundColor = color;
	}, [color]);
	
	...
}

Давайте теперь добавим кнопку для смены цвета в наш компонент:
return (
	<div>
		<h1>React App</h1>
		<button onClick={changeColor}>change</button>
	</div>
);

Добавим также функцию обработчика клика, которая будет менять наш цвет на оранжевый:
function changeColor() {
	setColor('orange');
}

Предположим, что теперь мы хотим, чтобы цвет у нас менялся не только по клику на кнопку, но и по нажатию Enter на клавиатуре. В обычной React жизни прослушивать глобальный объект window использовав addEventListener нельзя. Для этого у нас есть эффекты. Давайте добавим это действие с помощью useEffect.

Напишем функцию обработчика по клику на Enter. Пусть цвет в этом случае меняется на красный:
function handleEnter(event) {
	if (event.keyCode === 13) {
		setColor('red');
	}
}

Привяжем теперь прослушивание событий к window в хуке useEffect:
useEffect(() => {
	document.body.style.color = color;
	
	window.addEventListener('keydown', handleEnter);
}, [color]);

Если у нас есть какая-то установочная функция, то нам всегда нужно в useEffect возвращать код очистки или отписки, чтобы избежать проблем в дальнейшем. В данном случае нам нужно после прикрепления addEventListener вернуть его удаление:
useEffect(() => {
	document.body.style.color = color;
	
	window.addEventListener('keydown', handleEnter);
	
	return () => {
		window.removeEventListener('keydown', handleEnter);
	};
}, [color]);


У хука useEffect есть еще вариации, которые специфичны и очень редко используются, поэтому мы остановимся на них кратко.

Первая вариация - это хук useLayoutEffect, который срабатывает до того, как браузер перерисует экран. Эту возможность вы можете использовать, чтобы вычислить размеры и позицию компонента взависимости от других элементов, чтобы затем при прорисовке браузер отобразил его сразу как и где нужно. Благодаря этому, к примеру, пользователь не увидит промежуточных перескоков компонента при измении положения или размеров, а только их финальные версии.

Вторая вариация - это хук useInsertionEffect, который срабатывает перед какими либо изменениями DOM дерева, то есть тогда, когда еще рефы не прикреплены и DOM не обновлен. Применяется в основном там, где нужно вставить динамические стили из CSS-in-JS библиотек до изменения DOM.


5)Пятая группа содержит хуки для улучшения производительности приложения. Это такие хуки, как useMemo, useCallback, useTransition и useDeferredValue.
Вне категорий

 Первый хук для оптимизации производительности, который мы рассмотрим - это useMemo.

Данный хук помогает кэшировать результаты ресурсоемких операций между моментами перерисовки экрана и соответственно может помочь избежать лишних объемных вычислений. Такое кэширование называют еще мемоизацией.

Посмотрим, как это работает. Давайте создадим компонент с кнопкой и заголовком h3:
return (
	<div>
		<h3>Text</h3>
		<button>click:</button>
	</div>
);

А сейчас сделаем так, чтобы по клику на заголовок его цвет менялся с оранжевого на зеленый и обратно. Для начала заведем стейт isGreen:
const [isGreen, setIsGreen] = useState(false);

Добавим в атрибут style заголовка условие изменения цвета заголовку и навесим обработчик клика:
<h3 onClick={() => setIsGreen(!isGreen)}
	style={{ color: isGreen ? 'green' 
		: 'orangered' }} 
>Text</h3>

Пусть у нас также будет какое-то значение, которое будет увеличиваться при клике по нашей кнопочке на единицу. Заведем для него стейт:
const [num, setNum] = useState(0);

Добавим обработку клика по кнопке:
<button onClick={() => setNum(num + 1)}>
	clicks
</button>

Пусть также у нас будет некая функция square, которая будет возвращать квадрат значения num. Результат вызова функции мы будем записывать в переменную result:
const result = square(num);

function square(num) {
	return num * num;
}

Выведем result в тексте кнопки:
<button onClick={() => setNum(num + 1)}>
	clicks: {result}
</button>

В результате у нас получилось следующее: при клике на кнопку меняется значение num, которое затем возводится в квадрат, а при клике на заголовок меняется цвет заголовка.

У нас очень маленький компонент, все работает быстро, несмотря на то, что при клике по заголовку для смены его цвета весь компонент отрисовывается заново, соответственно происходят заново и вычисления, которые привязаны к кнопке, это даже при том, что мы к ней не прикасались. А теперь представьте, если бы наши вычисления были объемными и все пересчитывалось бы заново каждый раз.

Давайте, немного утяжелим нашу функцию, теперь она будет думать немного дольше. Таким образом мы сымитируем долгие вычисления:
function square(num) {
	let startTime = performance.now();
	
	while (performance.now() - startTime < 500) {
		// Just do nothing ...
	}
	
	return num * num;
}

Понажимайте теперь на заголовок. Получается, что теперь из-за долгой работы функции square (а кнопку-то мы не трогаем) мы целую вечность должны ждать, чтобы у заголовка поменялся цвет!

Здесь к нам на помощь и придет хук useMemo. Для этого, нам нужно первым параметром передать функцию, вычисляющую значение, которое мы хотим кэшировать, данная функция должна быть чистой и не принимать никаких параметров. А вторым параметром - зависимости в квадратных скобках, другими словами, все реактивные значения, которые участвуют в коде функции. Таким образом, в result мы теперь впишем такую конструкцию:
const result = useMemo(() => square(num), [num]);

Снова понажимаем на заголовок. Теперь, если мы не трогаем кнопку с вычислениями и не меняем таким образом значение стейта num, то ничего не пересчитывается, и React отображает кэшированное значение в кнопке, поэтому наш заголовок быстренько меняет свой цвет. 

				API memo в React

-помогает избегать повторного рендеринга компонента, если его пропсы остаются неизменными.

Давайте разберем это на примере. Создадим комопонент App, в котором будет два инпута, в которые, предположим, вводятся имя и фамилия:
return (
	<div>
		<label>
			name:
			<input value={name} onChange={(e) 
				=> setName(e.target.value)} /> 
		</label>
		<br />
		<label>
			surname:
			<input value={surn} onChange={(e) 
				=> setSurn(e.target.value)} /> 
		</label>
	</div>
);

Добавим в начало компонента стейты для них:
const [name, setName] = useState('');
const [surn, setSurn] = useState('');

Сделаем еще и дочерний компонент Child.js, пусть он выводит приветствие, в котором будет отображаться вводимое имя. Также в консоли будет выводится строка 'child render' при каждом рендеринге этого компонента:

function Child({ name }) {
	console.log('child render');
	return <h3>Hello {name}!</h3>;
}

Добавим Child в верстку основного компонента после последнего инпута и будем в качестве пропса передавать ему имя:
<Child name={name} />

Импортируем его в основной комопонент:
import Child from './Child';

А теперь откроем консоль и будем в поля ввода вбивать имя и фамилию. Здесь мы увидим, что даже при вводе символов в поле для фамилии, наш дочерний компонент будет каждый раз перерисовываться. Никаких проблем, ведь у нас небольшой компонент. Но представьте, если бы этот компонент отображал большое количество данных и при этом, каждый раз перерисовывался.

А сейчас давайте обернем дочерний компонент в memo, и посмотрим, как изменится рендеринг. Для начала импортируем в него memo:
import { memo } from 'react';

Затем создадим новую переменную и присвоим ей наш Child, обернутый в memo. У нас получится следующее функциональное выражение:
const Child = memo( function Child({ name }) {			
	console.log('child render');
	return <h3>Hello {name}!</h3>;
});

Откроем консоль и будем снова вводить имя и фамилию в поля. Сейчас мы видим, что при введении фамилии, наш дочерний компонент не перерисовывается.

Нужно помнить, что это не будет работать, если при неизменных пропсах будут меняться стейты, задействованные комопонентом или контекст, использующий изменения. 

Хук оптимизации производительности useCallback в React
 
Хук useCallback подобен API useMemo, отличие заключается в том, что первый кэширует значение между моментами перерисовки экрана, а второй callback-функцию. Это позволяет нам не перезапускать ресурсозатратные функции, когда это не требуется и может использоваться при передаче функции в дочерние компоненты.

Давайте разберемся подробнее на примере. Для начала создадим компонент App и заведем в нем стейт num:
const [num, setNum] = useState(0);

Пусть у нас будет кнопка, по клику на которую num увеличивается на 1 и абзац, в котором мы будем выводить значение num:
return (
	<div>
		<button onClick={() => setNum(num + 1)}>click</button>
		<p>clicks: {num}</p>
	</div>
);

А сейчас, предположим, что у нас в App выводится еще какой-то список с элементами, который мы будем дополнять по нажатию другой кнопки. Для хранения элементов этого списка мы заведем стейт items:
const [items, setItems] = useState([]);

И затем напишем функцию addItem для их добавления:
function addItem() {
	setItems([...items, 'new item']);
}

Теперь давайте напишем код для отображения элементов списка и вынесем его в дочерний компонент Items, который в виде пропсов будет получать массив элементов и функцию для их добавления. Не забудем добавить вывод в консоль, чтобы видеть когда наш Items будет перерисовываться:
function Items({ items, addItem }) {

	const result = items.map((item, index) => {
		return <p key={index}>{item}</p>;
	});
	
	console.log('Items render');
	
	return (
		<div>
			<h3>Our items</h3>
			{result}
			<button onClick={addItem}>add item</button>
		</div>
	);
}

export default Items;

Разместим Items в конце компонента App и будем передавать ему массив items и функцию для добавления элементов addItem:
return (
	<>
		<div>
			<button onClick={() => setNum(num + 1)}>click</button>
			<p>clicks: {num}</p>
			<br />
		</div>
		<Items items={items} addItem={addItem} />
	</>
);

А теперь понажимаем на кнопочки и убедимся, что num растет и новые элементы добавляются в список. А открыв консоль, мы увидим, что наш список перерисовывается каждый раз, даже если мы кликаем по кнопке, которая увеличивает num.

Если у нас маленький списочек, то все в порядке, а если предполагается, что он будет объемным и там много чего еще есть? Не беда - скажете вы, ведь на прошлом уроке мы рассмотрели API memo, чтобы как раз избегать ненужных перерисовок компонента.

Так давайте обернем наш компонент Items в memo и все дела. Кстати это можно сделать прямо при экспорте Items:
export default memo(Items);

Не забудем импортировать memo:
import { memo } from 'react';

А теперь откроем консоль и понажимаем на кнопочки. Все старания впустую! Мы мемоизировали компонент, но при нажатии на кнопку 'click' компонент Items все равно перерисовывается каждый раз.

Дело все в том, что когда родительский компонент перерисовывается, его функции пересоздаются заново - это касается и нашей функции addItem, которую мы передаем в Items.

Именно в этот момент нам поможет хук useCallback. Давайте применим его. Для начала импортируем его в App:
import { useCallback } from 'react';

Затем переделаем простое объявление функции addItem в Function Expression, укажем в качестве первого параметра для useCallback нашу функцию в виде колбэка. Вторым параметром в квадратных скобочках укажем зависимости - все реактивные переменные, участвующие в функции, в нашем случае это массив items:
const addItem = useCallback(() => {
	setItems(() => [...items, 'New item']);
}, [items]);

Готово! Таким образом мы закэшировали функцию. Нажимаем снова на кнопочки и видим, что теперь при нажатии на кнопку 'click' наш дочерний компонент не перерисовывается. 



Хук оптимизации производительности useTransition в React

-позволяет нам обновлять стейты без блокировки графического интерфейса.

С помощью данного хука мы можем задать обновлению какого-нибудь стейта низкий приоритет, что позволит обновлению других стейтов иметь высокий приоритет и выполняться без задержек.

В качестве примера можно привести фильтрацию выпадающего списка товаров при введении пользователем символов в поле поиска. Конечно, сам список может отображаться с какой-то задержкой, но нам бы не хотелось, чтобы символы вводились в поле поиска с задержкой.

Давайте посмотрим, как в таких случаях нам может помочь хук useTransition. Предположим, у нас есть кусок кода основного комопонента. Давайте его проанализируем:

import { useTransition } from 'react';
import { useState } from 'react';

function App() {
	const [isPending, startTransition] = useTransition();
	const [filterTerm, setFilterTerm] = useState('');
  
	const filteredProducts = filterProducts(filterTerm);
  
	function updateFilterHandler(event) {
		startTransition(() => {
			setFilterTerm(event.target.value);
		});
	}
 
	return (
		<div>
			<input type="text" onChange={updateFilterHandler} />
			<ProductList products={filteredProducts} />
		</div>
	);
}

Здесь мы видим две переменные для useTransition. Переменная isPending содержит булево значение и показывает закончен ли процесс обновления, а startTransition функцию, которая и позволяет снизить приоритет обновления:
const [isPending, startTransition] = useTransition();

Также у нас есть стейт filterTerm, в котором хранится вводимое в поле ввода выражение и функция setFilterTerm для его установки:
const [filterTerm, setFilterTerm] = useState('');

При вводе символов в инпут у нас каждый раз вызывается функция updateFilterHandler, в которой происходит обновление filterTerm. Именно здесь мы применяем наш хук useTransition, оборачивая функцию установки setFilterTerm в startTransition следующим образом:
function updateFilterHandler(event) {
	startTransition(() => {
		setFilterTerm(event.target.value);
	});
}

Таким образом, мы установили для обновления стейта filterTerm низкий приоритет и наше поле ввода останется отзывчивым.

При помощи переменной isPending мы можем показать пользователю, что обновление списка еще в процессе. Выведем эту информацию под полем ввода, пока список обновляется:
return (
	<div>
		<input type="text" onChange={updateFilterHandler} />
		{isPending && <p>updating ...</p>}
		<ProductList products={filteredProducts} />
	</div>
);



Хук оптимизации производительности useDeferredValue в React

Хук оптимизации производительности useDeferredValue, также как и useTransition, помогает ускорить работу графического интерфейса, но делает это немного по-другому.

Взгляните на прошлый урок и посмотрите, как в случае с useTransition мы оборачивали функцию обновления setFilterTerm. Так вот, код обновления стейта не всегда может быть доступен. Он может быть скрыт, например, в библиотеке, которую вы подключили. В этом случае мы можем воспользоваться хуком useDeferredValue. Тогда нам нужно обернуть либо сам стейт, либо результат, вычисляемый с помощью этого стейта, тем самым снизив его приоритет.

Давайте проанализируем следующий кусочек кода дочернего компонета ProductList:
import {useDeferredValue} from 'react'

function ProductList({ products }) {
	const deferredProducts = useDeferredValue(products);
	
	return (
		<ul>
			{deferredProducts.map((product) => (
				<li>{product}</li>
			))}
		</ul>
	);
}

Обратите внимание, что здесь мы обернули в useDeferredValue саму переменную products, которую мы взяли из пропсов компонента. Затем мы записали результат в deferredProducts, с которой и будем работать далее:
const deferredProducts = useDeferredValue(products);

Теперь, если в кусочке коде главного компонента, который мы рассматривали на прошлом уроке, убрать строчку:
const [isPending, startTransition] = useTransition();

И строчку с использованием isPending:
{isPending && <p>updating ...</p>}

А также снять обертку с функции setFilterTerm, то мы получим тот же результат, что и на прошлом уроке:
function updateFilterHandler(event) {
	setFilterTerm(event.target.value);
Есть еще хуки useDebugValue, useId, useSyncExternalStore, которые не относят к какой-либо категории.

*Свои хуки
Также кроме использования встроенных хуков, вы при необходимости можете создать свой собственный хук. 